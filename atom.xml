<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZCS的个人博客</title>
  
  
  <link href="https://zheyday.github.io/atom.xml" rel="self"/>
  
  <link href="https://zheyday.github.io/"/>
  <updated>2020-07-11T08:48:41.172Z</updated>
  <id>https://zheyday.github.io/</id>
  
  <author>
    <name>zcs</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mysql+redis+rabbitmq秒杀系统设计</title>
    <link href="https://zheyday.github.io/2020/02/04/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    <id>https://zheyday.github.io/2020/02/04/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</id>
    <published>2020-02-04T05:58:54.000Z</published>
    <updated>2020-07-11T08:48:41.172Z</updated>
    
    <content type="html"><![CDATA[<h2 id="秒杀系统设计"><a href="#秒杀系统设计" class="headerlink" title="秒杀系统设计"></a>秒杀系统设计</h2><h3 id="微服务和分布式"><a href="#微服务和分布式" class="headerlink" title="微服务和分布式"></a>微服务和分布式</h3><p>微服务：根据业务将整体拆分成一个个独立的服务单元，每个单元只负责一个功能</p><p>分布式：将服务分部到多个服务器上，单体应用和微服务都可以是分布式</p><h3 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h3><p>每个URI代表一种资源，资源是实体，可以有多种表现形式，称为表现层。访问网站就代表了客户端和服务器的一个互动过程。客户端通过HTTP动词，对服务器资源进行操作，完成表现层状态转化</p><p>所以URI中只能有名词</p><h3 id="流量治理"><a href="#流量治理" class="headerlink" title="流量治理"></a>流量治理</h3><p>前端：页面动静分离、CDN缓存</p><p>用户侧限流：</p><p>网关限流：</p><p>应用系统限流：</p><p>令牌桶算法：</p><p>分流</p><h3 id="redis集群"><a href="#redis集群" class="headerlink" title="redis集群"></a>redis集群</h3><p>对于秒杀系统来说，商品信息和秒杀成功信息都保存在redis中，所以要保证redis的高可用。</p><p>主从和哨兵都没法解决写压力，所以采用集群</p><p>使用三个节点作为集群，每个master再挂三个slave，当master挂机的时候选举一个slave作为master</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>现在有如下几个服务</p><p><img src="//zheyday.github.io/2020/02/04/秒杀系统设计/image-20191110162017587.png" alt="image-20191110162017587"></p><p>EurekaServerSingle是服务注册中心</p><p>OauthServerApplication是OAuth2服务器</p><p>Zuul是网关，负责服务转发、负载均衡、熔断</p><p>Seckill是秒杀服务</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>新建一个JMeter测试计划，添加如下内容</p><p><img src="//zheyday.github.io/2020/02/04/秒杀系统设计/image-20191110163002592.png" alt="image-20191110163002592"></p><p>添加步骤：</p><ol><li>右击测试计划 –&gt; 添加 –&gt; 线程 （用户）–&gt; 线程组，线程数设置5000，Ramp-Up设为1，也就是1启动5000个线程</li><li>右击线程组 –&gt; 添加  –&gt;取样器 –&gt; HTTP请求，配置要访问的路径</li><li>右击HTTP请求 –&gt; 添加 –&gt; 配置元件–&gt; HTTP信息头管理器，这个下面说明</li><li>右击线程组 –&gt; 添加  –&gt;监听器 –&gt;察看结果树/聚合报告</li></ol><p>说明一下：</p><p>由于所有的资源都被OAuth2保护起来了，所以想要访问必须要经过登陆授权的步骤，为了方便起见，先在浏览器正常访问一个资源进行授权，然后获取里面的cookie值，放入HTTP信息头管理器中</p><p><img src="//zheyday.github.io/2020/02/04/秒杀系统设计/image-20191110164022950.png" alt="image-20191110164022950"></p><p>在Cookie中有个 JSESSIONID ，把它们整个放到HTTP信息头管理器</p><p><img src="//zheyday.github.io/2020/02/04/秒杀系统设计/image-20191110164215773.png" alt="image-20191110164215773"></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="一、最简单的加锁"><a href="#一、最简单的加锁" class="headerlink" title="一、最简单的加锁"></a>一、最简单的加锁</h3><p>程序加synchronized锁，先读取数据库信息，然后自减，再更新，所有的逻辑操作都在程序中完成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/order"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reduceStack</span><span class="params">(@Param(<span class="string">"id"</span>)</span> String id) </span>&#123;</span><br><span class="line">        Integer number;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            Seckill seckill = seckillService.getById(id);</span><br><span class="line">            number = seckill.getNumber();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                seckill.setNumber(--number);</span><br><span class="line">                seckillService.updateById(seckill);</span><br><span class="line">                number = seckillService.getById(id).getNumber();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ResultData&lt;Integer&gt; resultData = <span class="keyword">new</span> ResultData&lt;Integer&gt;(<span class="number">20000</span>, <span class="string">"number"</span>, number);</span><br><span class="line"></span><br><span class="line">        Gson gson = <span class="keyword">new</span> GsonBuilder().setDateFormat(DateFormat.FULL, DateFormat.FULL).create();</span><br><span class="line"><span class="comment">//        System.out.println(System.currentTimeMillis()-start);</span></span><br><span class="line">        <span class="keyword">return</span> gson.toJson(resultData);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="//zheyday.github.io/2020/02/04/秒杀系统设计/image-20191119183209284.png" alt="image-20191119183209284"></p><p>显然，可以看到吞吐量低</p><p>因为这段程序进行了加锁，而且所有的逻辑都在程序里执行，和数据库的交互也存在时间延迟</p><h3 id="二、在数据库中完成"><a href="#二、在数据库中完成" class="headerlink" title="二、在数据库中完成"></a>二、在数据库中完成</h3><p>自检操作在数据库中完成，SeckillMapper中添加函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Update</span>(<span class="string">"update seckill set number=number-1 where id=1 and number &gt; 0 "</span>)</span><br><span class="line">   <span class="function">Integer <span class="title">minusOne</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>减库存逻辑函数修改为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/order"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reduceStack</span><span class="params">(@Param(<span class="string">"id"</span>)</span> Integer id) </span>&#123;</span><br><span class="line"><span class="comment">//        long start=System.currentTimeMillis();</span></span><br><span class="line">        Integer number=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (seckillService.minusStack(id)!=<span class="number">0</span>)&#123;</span><br><span class="line">            number = seckillService.getById(id).getNumber();</span><br><span class="line">        &#125;</span><br><span class="line">        ResultData&lt;Integer&gt; resultData = <span class="keyword">new</span> ResultData&lt;Integer&gt;(<span class="number">20000</span>, <span class="string">"number"</span>, number);</span><br><span class="line"></span><br><span class="line">        Gson gson = <span class="keyword">new</span> GsonBuilder().setDateFormat(DateFormat.FULL, DateFormat.FULL).create();</span><br><span class="line"><span class="comment">//        System.out.println(System.currentTimeMillis()-start);</span></span><br><span class="line">        <span class="keyword">return</span> gson.toJson(resultData);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>测试结果</p><p><img src="//zheyday.github.io/2020/02/04/秒杀系统设计/image-20191119092941253.png" alt="image-20191119092941253"></p><p>由于去掉了锁的限制，整个逻辑只有对数据库一行代码的操作，在提升速度的同时也保证了原子性</p><h3 id="三、使用redis"><a href="#三、使用redis" class="headerlink" title="三、使用redis"></a>三、使用redis</h3><h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h4><p>这个属于悲观锁，原理大概是一个线程在操作数据的时候加一把锁，不允许其他线程进行操作，主要利用setnx命令（ SET if Not exists ），就是当key不存在时，将key设为value，并返回1，否则返回0。操作结束后将该key删除。同时为了防止发生死锁，要设置key的过期时间</p><p>这里设置key为lock，value=1，过期时间是1s，具体的redisUtil方法后面贴出</p><p>goods的值在初始化中进行设置，预先加载到内存中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!redisUtil.setnx(<span class="string">"lock"</span>,<span class="number">1</span>,<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"so busy"</span>;</span><br><span class="line">    Integer number = (Integer) redisUtil.get(<span class="string">"goods"</span>);</span><br><span class="line">    <span class="keyword">if</span> (number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         number=redisUtil.decrBy(<span class="string">"goods"</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    redisUtil.unlock(<span class="string">"lock"</span>);</span><br></pre></td></tr></table></figure><p>测试结果如下，同时也没有出现超卖情况</p><p><img src="//zheyday.github.io/2020/02/04/秒杀系统设计/image-20191119101549640.png" alt="image-20191119101549640"></p><h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>乐观锁是基于数据版本实现的，数据库中是在表中添加version字段，在读取数据时将version一同读出，之后进行写操作时对version加1。提交数据时如果该值比当前表中记录的值大，则更新，否则就是过期数据。在redis中，可以使用watch加事务实现，通过watch监视指定的key，当exec时如果key发生改变，则整个事务失败</p><p><font color="red">注意</font></p><p>redis是单线程，单个命令的执行是原子性的，但是redis在事务上没有任何原子性的限制，所以事务不是原子性的，中间某条指令的失败不会导致前面指令的回滚，也不会造成后续指令停止。事务可以理解为一个打包的批量执行脚本，在执行MULTI指令后，会将所有指令放入一个队列中，最后执行EXEC命令之后，Redis再执行队列里的命令。</p><p>但是</p><ol><li>discard可以取消事务</li><li>watch一个key，如果事务exec之前这个key被改动，那么事务将被打断</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">watch</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">       redisTemplate.watch(key);</span><br><span class="line">       Integer number = (Integer) get(key);</span><br><span class="line">       <span class="keyword">if</span> (number &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       redisTemplate.multi();</span><br><span class="line">       redisTemplate.opsForValue().decrement(key, <span class="number">1</span>);</span><br><span class="line">       List&lt;Object&gt; list = redisTemplate.exec();</span><br><span class="line">       <span class="keyword">return</span> list.size() != <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><img src="//zheyday.github.io/2020/02/04/秒杀系统设计/image-20191119160912922.png" alt="image-20191119160912922"></p><p>从结果上看，两种方法的吞吐量好像差不多，乐观锁的还低一点，不太明白这样是否正常，按理说应该高一点才对。</p><h4 id="lua脚本"><a href="#lua脚本" class="headerlink" title="lua脚本"></a>lua脚本</h4><p>上面乐观锁的处理略显臃肿，需要watch一个key，还要开启事务等一系列操作。那么如果优雅的进行原子性的操作呢？这时候lua就出来了</p><p>使用lua脚本后，redis程序会有明显的性能提升</p><ul><li>减少网络io操作：上节的操作会向redis服务器发起多次请求，现在用一个请求即可完成</li><li>原子操作：redis会将整个脚本作为一个整体运行</li><li>复用：脚本会永久存储在redis中</li></ul><p>redis-cli中先试试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval &quot;return redis.call(&apos;DECRBY&apos;,KEYS[1],1)&quot; key-num [key1 key2 ....] [value1 value2....]</span><br></pre></td></tr></table></figure><ul><li>eval命令表示执行lua脚本</li><li>双引号里是具体的内容</li><li>KEYS[1]对应的是后面传入的key参数，还有ARGV[1]对应的是value参数</li><li>key-num表示key的个数</li><li>[key1 key2]是key作为参数传给lua，要和key-num对应</li><li>[value1 value2]也是参数</li></ul><p><strong>RedisUtil中添加</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> DefaultRedisScript&lt;Long&gt; redisScript;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        redisScript = <span class="keyword">new</span> DefaultRedisScript&lt;&gt;();</span><br><span class="line">        redisScript.setResultType(Long<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        redisScript.setScriptText(<span class="string">"local number = tonumber(redis.call('get',KEYS[1]))\n"</span> +</span><br><span class="line">                <span class="string">"if number &lt;= 0 then\n"</span> +</span><br><span class="line">                <span class="string">"    return 0;\n"</span> +</span><br><span class="line">                <span class="string">"end\n"</span> +</span><br><span class="line">                <span class="string">"return redis.call('DECRBY',KEYS[1],1);"</span>);</span><br><span class="line"><span class="comment">//        redisScript.setScriptSource(new ResourceScriptSource(new ClassPathResource("seckill.lua")));</span></span><br><span class="line"><span class="comment">//        redisScript.setLocation(new ClassPathResource("seckill.lua"));</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>注意：这里貌似只能使用Long，Integer会报错</p><p>直接把脚本写成string，不用每次都要从文件加载，速度会快一些</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">lua</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">       List&lt;String&gt; keyList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       keyList.add(key);</span><br><span class="line">       <span class="keyword">return</span> redisTemplate.execute(redisScript, keyList);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>keyList用于存储需要用到的key</p><p><img src="//zheyday.github.io/2020/02/04/秒杀系统设计/image-20191119183025749.png" alt="image-20191119183025749"></p><h3 id="四、RabbitMQ出场"><a href="#四、RabbitMQ出场" class="headerlink" title="四、RabbitMQ出场"></a>四、RabbitMQ出场</h3><p>RabbitMQ并不是为了取代redis，只是存储秒杀信息用于订单处理，所以在秒杀这部分功能还是使用redis</p><p>配置一个队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitDirectConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">seckillQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"seckill"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是用redis进行交互，成功后将手机号放入队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/orderMq"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reduceStackMq</span><span class="params">(@Param(<span class="string">"id"</span>)</span> Integer id, @<span class="title">Param</span><span class="params">(<span class="string">"phone"</span>)</span> String phone) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (localOverMap.get(id))</span><br><span class="line">            <span class="keyword">return</span> commonUtil.toJson(ResponseState.OK, <span class="string">"number"</span>, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        Long number = redisUtil.lua(KEY, SUCCESS, phone);</span><br><span class="line">        <span class="keyword">if</span> (number &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//            成功</span></span><br><span class="line">            amqpTemplate.convertAndSend(<span class="string">"seckill"</span>,phone);</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            localOverMap.put(id,<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> commonUtil.toJson(ResponseState.OK, <span class="string">"number"</span>, number);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h2><p><font color="red">注意</font></p><ol><li><p>如果线程数选的过大，比如10w，可能会报<font color="red"> Address already in use : connect </font><br>原因：windows提供给TCP/IP链接的端口为 1024-5000，并且要四分钟来循环回收它们，就导致我们在短时间内跑大量的请求时将端口占满了，导致如上报错。 </p><p>解决办法（在jmeter所在服务器操作）：</p><p>1.cmd中输入regedit命令打开注册表；</p><p>2.在 HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters右键Parameters；</p><p>3.添加一个新的DWORD，名字为MaxUserPort，如果有的话就不用新建；</p><p>4.然后双击MaxUserPort，输入数值数据为65534，基数选择十进制；</p><p>5.完成以上操作，务必重启机器，问题解决，亲测有效；</p></li><li><p><font color="red"> org.apache.http.conn.HttpHostConnectException: Connect to localhost:80</font><br>JMeter的HTTP请求里的服务器名称要和工程里application.yml配置一样，比如都是localhost或者192.168.0.xxx</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;秒杀系统设计&quot;&gt;&lt;a href=&quot;#秒杀系统设计&quot; class=&quot;headerlink&quot; title=&quot;秒杀系统设计&quot;&gt;&lt;/a&gt;秒杀系统设计&lt;/h2&gt;&lt;h3 id=&quot;微服务和分布式&quot;&gt;&lt;a href=&quot;#微服务和分布式&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>SpringCloud打包docker</title>
    <link href="https://zheyday.github.io/2019/11/09/SpringCloud%E6%89%93%E5%8C%85docker/"/>
    <id>https://zheyday.github.io/2019/11/09/SpringCloud%E6%89%93%E5%8C%85docker/</id>
    <published>2019-11-09T11:14:41.367Z</published>
    <updated>2020-05-06T08:17:59.557Z</updated>
    
    <content type="html"><![CDATA[<p>几个模块本地测试完之后，将各个模块打包成docker镜像</p><p>遇到的坑放在最后，如果哪一步遇到了问题可以先行查看</p><p>需要在环境变量中配置DOCKER_HOST</p><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>以eureka-server-single模块为例，在模块根路径下创建Dockerfile文件</p><p><img src="//zheyday.github.io/2019/11/09/SpringCloud打包docker/image-20191109191701501.png" alt="image-20191109191701501"></p><p>内容如下</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> java:<span class="number">8</span></span><br><span class="line"><span class="keyword">VOLUME</span> /tmp</span><br><span class="line"><span class="keyword">ADD</span> target/eureka-server-single-0.0.1-SNAPSHOT.jar app.jar</span><br><span class="line"><span class="keyword">RUN</span> bash -c 'touch /app.jar'</span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8761</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span> ["java","-jar","/app.jar"]</span><br></pre></td></tr></table></figure><p>配置是网上找的，大致说明一下意思：</p><p>FROM是基础镜像</p><p>ADD的前半部分是项目打成jar包之后的路径</p><p>EXPOSE是要暴露的端口</p><h2 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h2><p>在属性一栏配置一下仓库地址，因为最后要上传到阿里云镜像</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Greenwich.SR1<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">docker.registry</span>&gt;</span>registry.cn-shanghai.aliyuncs.com/zcs<span class="tag">&lt;/<span class="name">docker.registry</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>打包使用了dockerfile-maven-plugin，因此在build下配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.spotify<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dockerfile-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                     <span class="tag">&lt;<span class="name">id</span>&gt;</span>default<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                     <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                         <span class="tag">&lt;<span class="name">goal</span>&gt;</span>build<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                         <span class="tag">&lt;<span class="name">goal</span>&gt;</span>push<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                     <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                 <span class="comment">&lt;!--     镜像名称--&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">repository</span>&gt;</span>$&#123;docker.registry&#125;/$&#123;project.artifactId&#125;<span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--    镜像的tag 默认就是latest--&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">tag</span>&gt;</span>latest<span class="tag">&lt;/<span class="name">tag</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">dockerfile</span>&gt;</span>Dockerfile<span class="tag">&lt;/<span class="name">dockerfile</span>&gt;</span></span><br><span class="line">                 <span class="comment">&lt;!--     Dockerfile的路径--&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">contextDirectory</span>&gt;</span>$&#123;project.basedir&#125;<span class="tag">&lt;/<span class="name">contextDirectory</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">buildArgs</span>&gt;</span></span><br><span class="line">                     <span class="comment">&lt;!--     项目jar包路径--&gt;</span></span><br><span class="line">                     <span class="comment">&lt;!--     finalName = artifactId + version--&gt;</span></span><br><span class="line">                     <span class="tag">&lt;<span class="name">JAR_FILE</span>&gt;</span>target/$&#123;project.build.finalName&#125;.jar<span class="tag">&lt;/<span class="name">JAR_FILE</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;/<span class="name">buildArgs</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><p>配置完上述之后，直接用maven的Lifecycle打包即可</p><h2 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker-compose"></a>docker-compose</h2><h2 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h2><h3 id="1、-打包失败"><a href="#1、-打包失败" class="headerlink" title="1、 打包失败"></a>1、 打包失败</h3><p>要注意打包的项目是不是依赖其他的包。比如本项目需要oauth2模块先启动</p><h3 id="2、连不上宿主机数据库"><a href="#2、连不上宿主机数据库" class="headerlink" title="2、连不上宿主机数据库"></a>2、连不上宿主机数据库</h3><p>ipconfig可以看出多了一个DockerNAT，docker内部是通过桥和宿主机通信的，因此ip地址也变了</p><p><img src="//zheyday.github.io/2019/11/09/SpringCloud打包docker/image-20191109192925511.png" alt="image-20191109192925511"></p><p>可以看出，对docker来说windows的ip是10.0.75.1，,docker自己是10.0.75.2，而我们平时连接数据库的时候是通过root@localhost用户来连接的，所以需要更改两个地方</p><ol><li><p>在项目中更改applicaiton.yml数据库的配置，只需要将url的localhost改为10.0.75.1即可</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://10.0.75.1/seckill?serverTimezone=UTC&amp;characterEncoding=UTF-8&amp;nullCatalogMeansCurrent=true</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>安装数据库的时候有可能我们只给了root@localhost用户权限，所以我们需要再创建一个用户并给权限</p><p>我这里使用的是mysql8</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create user &apos;root&apos;@&apos;10.0.75.2&apos; identified by &apos;123456&apos;;</span><br><span class="line">mysql&gt; grant all privileges on *.* to &apos;root&apos;@&apos;10.0.75.2&apos; with grant option;</span><br><span class="line">mysql&gt; flush privileges;</span><br></pre></td></tr></table></figure><p>对于以前的版本来说应该是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; grant all privileges on *.* to &apos;root&apos;@&apos;10.0.75.2&apos; identified by &apos;123456&apos; with grant option;</span><br></pre></td></tr></table></figure><p>这两项配置完之后就应该可以访问数据库了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;几个模块本地测试完之后，将各个模块打包成docker镜像&lt;/p&gt;
&lt;p&gt;遇到的坑放在最后，如果哪一步遇到了问题可以先行查看&lt;/p&gt;
&lt;p&gt;需要在环境变量中配置DOCKER_HOST&lt;/p&gt;
&lt;h2 id=&quot;Dockerfile&quot;&gt;&lt;a href=&quot;#Dockerfile&quot; </summary>
      
    
    
    
    
    <category term="SpringCloud" scheme="https://zheyday.github.io/tags/SpringCloud/"/>
    
    <category term="docker" scheme="https://zheyday.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud-OAuth2结合zuul实现SSO</title>
    <link href="https://zheyday.github.io/2019/10/11/SpringCloud-OAuth2%E5%AE%9E%E7%8E%B0SSO/"/>
    <id>https://zheyday.github.io/2019/10/11/SpringCloud-OAuth2%E5%AE%9E%E7%8E%B0SSO/</id>
    <published>2019-10-11T06:19:39.000Z</published>
    <updated>2019-10-18T12:09:29.632Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>爬了两天的坑终于上来了，看别人写的很简单，自己写的时候就各种问题，网上SSO文章很多，写的时候就各种问题（自己太菜了）。记录一下，以后方便查看。</p><p>关于OAuth2认证和授权服务器见上一篇</p><p><a href="https://zheyday.github.io/2019/10/07/SpringCloud-OAuth2和JWT/">https://zheyday.github.io/2019/10/07/SpringCloud-OAuth2%E5%92%8CJWT/</a></p><p><strong><font color="#0099ff">项目地址</font></strong>：</p><p><a href="https://github.com/zheyday/SpringCloudStudy" target="_blank" rel="noopener">https://github.com/zheyday/SpringCloudStudy</a></p><p>使用git工具</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout sso</span><br></pre></td></tr></table></figure><p>参考资料：</p><p><a href="https://www.cnblogs.com/cjsblog/p/10548022.html" target="_blank" rel="noopener">https://www.cnblogs.com/cjsblog/p/10548022.html</a></p><p><a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="noopener">阮一峰OAuth2讲解</a><br><a href="https://blog.csdn.net/WSM960921/article/details/98222004" target="_blank" rel="noopener">https://blog.csdn.net/WSM960921/article/details/98222004</a></p><h2 id="什么是SSO"><a href="#什么是SSO" class="headerlink" title="什么是SSO"></a>什么是SSO</h2><p>英文全称single Sign On，中文名单点登录。就是在多应用系统中，用户只需要登录一次就可以访问所有信任服务。SSO通过将用户登陆信息映射到浏览器cookie中，解决其他服务免登陆获取用户session的问题。</p><h2 id="大体框架"><a href="#大体框架" class="headerlink" title="大体框架"></a>大体框架</h2><p>项目中一个有5个模块：</p><ul><li><p>oauth-server是认证和授权服务，负责令牌的发放</p></li><li><p>zuul是网关服务，实现统一授权</p></li><li><p>eureka-client和eureka-client1是两个应用服务</p></li><li><p>eureka-server-single是eureka注册中心</p></li></ul><p>要实现的功能就是通过zuul端口访问eureka-client，首次需要登录，然后内部跳转到oauth-server中进行认证和授权，成功之后也可以不用登录访问eureka-client1。</p><h2 id="oauth-server"><a href="#oauth-server" class="headerlink" title="oauth-server"></a>oauth-server</h2><p>详见</p><p><a href="https://zheyday.github.io/2019/10/07/SpringCloud-OAuth2和JWT/">https://zheyday.github.io/2019/10/07/SpringCloud-OAuth2%E5%92%8CJWT/</a></p><p>更改了几个地方</p><h3 id="AuthorizationServerConfig"><a href="#AuthorizationServerConfig" class="headerlink" title="AuthorizationServerConfig"></a>AuthorizationServerConfig</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(ClientDetailsServiceConfigurer clients)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        clients.inMemory()</span><br><span class="line">                .withClient(<span class="string">"zuul"</span>)</span><br><span class="line">                .secret(<span class="keyword">new</span> BCryptPasswordEncoder().encode(<span class="string">"secret"</span>))</span><br><span class="line">                .scopes(<span class="string">"app"</span>)</span><br><span class="line">                .authorizedGrantTypes(<span class="string">"authorization_code"</span>, <span class="string">"password"</span>)</span><br><span class="line">                .redirectUris(<span class="string">"http://localhost:9110/login"</span>)</span><br><span class="line">        ;</span><br><span class="line"><span class="comment">//        clients.withClientDetails(new JdbcClientDetailsService(dataSource));</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="UserController"><a href="#UserController" class="headerlink" title="UserController"></a>UserController</h3><p>这个函数可以为其他模块资源服务器提供校验</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/oauth2_token"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/current"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Principal <span class="title">user</span><span class="params">(Principal principal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> principal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ResourceServerConfig"><a href="#ResourceServerConfig" class="headerlink" title="ResourceServerConfig"></a>ResourceServerConfig</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http</span><br><span class="line"><span class="comment">//                antMatcher表示只能处理/oauth2_token的请求</span></span><br><span class="line">                .antMatcher(<span class="string">"/oauth2_token/**"</span>)</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="application-yml"><a href="#application-yml" class="headerlink" title="application.yml"></a>application.yml</h3><p>添加了根地址，也就是每次访问这个服务都要加上 /oauth-server</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">9120</span></span><br><span class="line">#  url根地址 不配置的话会报invalid_token错误</span><br><span class="line">#  或者在zuul中配置也可以</span><br><span class="line">  servlet:</span><br><span class="line">    context-path: /oauth-server</span><br></pre></td></tr></table></figure><h2 id="Zuul"><a href="#Zuul" class="headerlink" title="Zuul"></a>Zuul</h2><p>zuul作为系统的入口，提供路由、统一授权等功能。</p><p>依赖见项目中</p><p><font color="red">注意：所有模块都引入了spring-cloud-starter-oauth2依赖，所以放入了项目的公共pom.xml中，实现oauth2只需要引用这一个就可以</font></p><h3 id="application-yml-1"><a href="#application-yml-1" class="headerlink" title="application.yml"></a>application.yml</h3><p>贴出主要配置，详细见项目中</p><p><code>sensitiveHeaders:</code>这个必须要。zuul在转发路由时，会改写request中的头部信息，设置成空就是不过滤</p><p>security.oauth2.resource：这个是和解析令牌相关的配置</p><p>资源服务器需要解析令牌验证正确性，方式有三种：</p><ol><li>如果令牌不是jwt非对称加密，那么访问/oauth/check_token直接验证token；<br>如果是非对称，访问/oauth/token_key获得公钥进行解析</li><li>访问认证服务器中的controller中的方法，获得Principal进行验证</li><li>在资源服务器本地配置，继承ResourceServerConfigurerAdapter接口，实现和认证服务器相同的加密方式</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">    <span class="attr">eureka-client:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/eureka-client/**</span></span><br><span class="line">      <span class="attr">sensitiveHeaders:</span></span><br><span class="line">      <span class="attr">serviceId:</span> <span class="string">eureka-client</span></span><br><span class="line">    <span class="attr">eureka-client1:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/eureka-client1/**</span></span><br><span class="line">      <span class="attr">sensitiveHeaders:</span></span><br><span class="line">      <span class="attr">serviceId:</span> <span class="string">eureka-client1</span></span><br><span class="line">    <span class="attr">oauth-server:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/oauth-server/**</span></span><br><span class="line">      <span class="attr">sensitiveHeaders:</span></span><br><span class="line">        <span class="attr">serviceId:</span> <span class="string">eureka-client</span></span><br><span class="line"><span class="comment">#认证服务器地址</span></span><br><span class="line"><span class="attr">oauth-server:</span> <span class="string">http://localhost:9120/oauth-server</span></span><br><span class="line"><span class="attr">security:</span></span><br><span class="line">  <span class="attr">oauth2:</span></span><br><span class="line"><span class="comment">#   和认证服务器中的client设置对应  </span></span><br><span class="line">    <span class="attr">client:</span></span><br><span class="line">  <span class="attr">client-id:</span> <span class="string">zuul</span></span><br><span class="line">      <span class="attr">client-secret:</span> <span class="string">secret</span></span><br><span class="line"><span class="comment">#   获取令牌地址</span></span><br><span class="line">      <span class="attr">access-token-uri:</span> <span class="string">$&#123;oauth-server&#125;/oauth/token</span></span><br><span class="line"><span class="comment">#      认证地址</span></span><br><span class="line">      <span class="attr">user-authorization-uri:</span> <span class="string">$&#123;oauth-server&#125;/oauth/authorize</span></span><br><span class="line">    <span class="attr">resource:</span></span><br><span class="line"><span class="comment">#      进行令牌校验</span></span><br><span class="line"><span class="comment">#      一、访问controller获取Principal</span></span><br><span class="line"><span class="comment">#      user-info-uri: $&#123;oauth-server&#125;/oauth2_token/current</span></span><br><span class="line"><span class="comment">#      prefer-token-info: false</span></span><br><span class="line"><span class="comment">#      二、访问授权服务器获取公钥 解析令牌</span></span><br><span class="line">      <span class="attr">jwt:</span></span><br><span class="line">        <span class="attr">key-uri:</span> <span class="string">$&#123;oauth-server&#125;/oauth/token_key</span></span><br></pre></td></tr></table></figure><h3 id="配置WebSecurityConfig"><a href="#配置WebSecurityConfig" class="headerlink" title="配置WebSecurityConfig"></a>配置WebSecurityConfig</h3><p>整个zuul模块只要添加这一个配置就可以</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableOAuth</span>2Sso</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http</span><br><span class="line">        <span class="comment">//需要授权的url    </span></span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="string">"/login"</span>).permitAll()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and().csrf().disable()</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="eureka-client（资源服务器）"><a href="#eureka-client（资源服务器）" class="headerlink" title="eureka-client（资源服务器）"></a>eureka-client（资源服务器）</h2><h3 id="application-yml-2"><a href="#application-yml-2" class="headerlink" title="application.yml"></a>application.yml</h3><p>新添如下，用于验证请求的令牌是否正确</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">security:</span></span><br><span class="line">  <span class="attr">oauth2:</span></span><br><span class="line">    <span class="attr">resource:</span></span><br><span class="line">      <span class="attr">id:</span> <span class="string">eureka-client</span></span><br><span class="line">      <span class="comment">#      资源服务器三种验证令牌方法</span></span><br><span class="line">      <span class="comment">#       一、在ResourceServerConfig中本地配置</span></span><br><span class="line">      <span class="comment">#      二、从认证服务器获取用户信息 解析出token</span></span><br><span class="line">      <span class="comment">#      user-info-uri: $&#123;oauth-server&#125;/oauth2_token/current</span></span><br><span class="line">      <span class="comment">#      prefer-token-info: false</span></span><br><span class="line">      <span class="comment">#       三、远程获取公钥 解析token</span></span><br><span class="line">      <span class="attr">jwt:</span></span><br><span class="line">        <span class="attr">key-uri:</span> <span class="string">$&#123;oauth-server&#125;/oauth/token_key</span></span><br></pre></td></tr></table></figure><h3 id="配置ResourceServerConfig"><a href="#配置ResourceServerConfig" class="headerlink" title="配置ResourceServerConfig"></a>配置ResourceServerConfig</h3><p>资源服务器只需要添加这一个配置即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableResourceServer</span></span><br><span class="line"><span class="comment">//Spring Security默认禁用注解 这里开启注解</span></span><br><span class="line"><span class="comment">// 结合@PreAuthorize("hasRole('admin')")用来判断用户对某个控制层的方法是否有访问权限</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity</span>(prePostEnabled = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceServerConfig</span> <span class="keyword">extends</span> <span class="title">ResourceServerConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http</span><br><span class="line"><span class="comment">//                配置需要权限的url</span></span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and().csrf().disable();</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//以下就是验证令牌的本地方法 如果使用这种，将上述application.yml的配置注释掉，同时将oauth2.jks放入resources文件夹</span></span><br><span class="line"><span class="comment">//    @Override</span></span><br><span class="line"><span class="comment">//    public void configure(ResourceServerSecurityConfigurer resources) throws Exception &#123;</span></span><br><span class="line"><span class="comment">//        resources.resourceId("app").tokenStore(tokenStore());</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    @Bean</span></span><br><span class="line"><span class="comment">//    public TokenStore tokenStore() &#123;</span></span><br><span class="line"><span class="comment">//        return new JwtTokenStore(jwtAccessTokenConverter());</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    /**</span></span><br><span class="line"><span class="comment">//     * 非对称加密算法对token进行签名</span></span><br><span class="line"><span class="comment">//     *</span></span><br><span class="line"><span class="comment">//     * @return</span></span><br><span class="line"><span class="comment">//     */</span></span><br><span class="line"><span class="comment">//    @Bean</span></span><br><span class="line"><span class="comment">//    public JwtAccessTokenConverter jwtAccessTokenConverter() &#123;</span></span><br><span class="line"><span class="comment">//        final JwtAccessTokenConverter converter = new JwtAccessTokenConverter();</span></span><br><span class="line"><span class="comment">//        // 导入证书</span></span><br><span class="line"><span class="comment">//        KeyStoreKeyFactory keyStoreKeyFactory =</span></span><br><span class="line"><span class="comment">//                new KeyStoreKeyFactory(new ClassPathResource("oauth2.jks"), "mypass".toCharArray());</span></span><br><span class="line"><span class="comment">//        converter.setKeyPair(keyStoreKeyFactory.getKeyPair("oauth2"));</span></span><br><span class="line"><span class="comment">//        return converter;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="red">注意：</font></p><p>如果使用本地验证方法，可能会报读取不到oauth2.jks的错误，因为默认不引用resources目录下的文件，需要在pom.xml中&lt;build&gt;下添加配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.*<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>启动顺序：</p><ul><li>eureka-server-single</li><li>oauth-server</li><li>zuul</li><li>eureka-client和eureka-ciient1</li></ul><p>通过zuul端口访问eureka-client下的方法 <a href="http://localhost:9110/eureka-client/hi" target="_blank" rel="noopener">http://localhost:9110/eureka-client/hi</a></p><p>会自动跳到oauth-server的登陆页面，输入用户名和密码登陆</p><img src="/2019/10/11/SpringCloud-OAuth2实现SSO/1570779345082.png"><p>看url，跳转到了oauth/authorize，这是授权接口，并且后面携带了一些zuul配置的信息</p><img src="/2019/10/11/SpringCloud-OAuth2实现SSO/1570779361869.png"><p>成功</p><img src="/2019/10/11/SpringCloud-OAuth2实现SSO/1570779411739.png"><p>访问eureka-client1不需要登陆</p><img src="/2019/10/11/SpringCloud-OAuth2实现SSO/1570779295223.png"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>写的比较简洁，但是做出来真的花费了两天的时间精力(还是太菜了)</p><p>没有什么文采，原理性的东西也写不出来，只能记录一下实践，大家共同交流</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;爬了两天的坑终于上来了，看别人写的很简单，自己写的时候就各种问题，网上SSO文章很多，写的时候就各种问题（自己太菜了）。记录一下，以后方便查</summary>
      
    
    
    
    
    <category term="SpringCloud" scheme="https://zheyday.github.io/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud：OAuth2和JWT</title>
    <link href="https://zheyday.github.io/2019/10/07/SpringCloud-OAuth2%E5%92%8CJWT/"/>
    <id>https://zheyday.github.io/2019/10/07/SpringCloud-OAuth2%E5%92%8CJWT/</id>
    <published>2019-10-07T10:12:51.000Z</published>
    <updated>2020-05-12T00:52:28.706Z</updated>
    
    <content type="html"><![CDATA[<p>搭建一个oauth2服务器，包括认证、授权和资源服务器</p><p>项目地址：<a href="https://github.com/zheyday/SpringCloudStudy" target="_blank" rel="noopener">https://github.com/zheyday/SpringCloudStudy</a></p><p>oauth分支</p><p><strong>参考资料</strong>：</p><p><a href="https://www.cnblogs.com/fp2952/p/8973613.html" target="_blank" rel="noopener">https://www.cnblogs.com/fp2952/p/8973613.html</a></p><p><a href="https://juejin.im/post/5c5ae6566fb9a049b3486e38" target="_blank" rel="noopener">https://juejin.im/post/5c5ae6566fb9a049b3486e38</a></p><p><a href="https://projects.spring.io/spring-security-oauth/docs/oauth2.html" target="_blank" rel="noopener">Spring OAuth2官方文档</a> </p><p>本文分为两个部分</p><ul><li>第一部分比较简单，将客户端信息和用户信息固定在程序里，令牌存储在内存中</li><li>第二部分从数据库读取用户信息，使用jwt生成令牌</li></ul><h2 id="一、简化版"><a href="#一、简化版" class="headerlink" title="一、简化版"></a>一、简化版</h2><p>使用Spring Initializr新建项目，勾选如下三个选项</p><img src="/2019/10/07/SpringCloud-OAuth2和JWT/1570420518382.png"><p><img src="//zheyday.github.io/2019/10/07/SpringCloud-OAuth2和JWT/1570420518382.png" alt="1570420518382"></p><p>pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    //只需要引用这一个 </span><br><span class="line">    //集成了spring-security-oauth2 spring-security-jwt spring-security-oauth2-autoconfigure</span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-oauth2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置Spring-Security"><a href="#配置Spring-Security" class="headerlink" title="配置Spring Security"></a>配置Spring Security</h3><p>新建类WebSecurityConfig 继承 WebSecurityConfigurerAdapter，并添加@Configuration @EnableWebSecurity注解，重写三个方法，代码如下，详细讲解在代码下面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserServiceDetail userServiceDetail;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PasswordEncoder <span class="title">passwordEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        auth.userDetailsService(userServiceDetail).passwordEncoder(passwordEncoder());</span><br><span class="line">        <span class="comment">//内存存储</span></span><br><span class="line"><span class="comment">//        auth</span></span><br><span class="line"><span class="comment">//                .inMemoryAuthentication()</span></span><br><span class="line"><span class="comment">//                .passwordEncoder(passwordEncoder())</span></span><br><span class="line"><span class="comment">//                .withUser("user")</span></span><br><span class="line"><span class="comment">//                .password(passwordEncoder().encode("user"))</span></span><br><span class="line"><span class="comment">//                .roles("USER");</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//忽略url</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        web.ignoring().antMatchers(<span class="string">"/js/**"</span>,<span class="string">"/fonts/**"</span>,<span class="string">"/css/**"</span>,<span class="string">"/login.html"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置了默认表单登陆以及禁用了 csrf 功能，并开启了httpBasic 认证</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> http</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http    <span class="comment">// 配置登陆页/login并允许访问</span></span><br><span class="line">                .formLogin().permitAll()</span><br><span class="line">                <span class="comment">// 登出页</span></span><br><span class="line">                .and().logout().logoutUrl(<span class="string">"/logout"</span>).logoutSuccessUrl(<span class="string">"/"</span>)</span><br><span class="line">                <span class="comment">// 其余所有请求全部需要鉴权认证</span></span><br><span class="line">                .and().authorizeRequests().anyRequest().authenticated()</span><br><span class="line">                <span class="comment">// 由于使用的是JWT，我们这里不需要csrf</span></span><br><span class="line">                .and().csrf().disable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AuthenticationManager <span class="title">authenticationManagerBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.authenticationManagerBean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要讲解一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception</span></span><br></pre></td></tr></table></figure><p>这个方法是用来验证用户信息的。将用户名和密码与数据库匹配，如果有这个用户才能认证成功。我们注入了一个<code>UserServiceDetail</code>，这个service的功能就是验证用户的。<code>.passwordEncoder(passwordEncoder())</code>是使用加盐解密。</p><p><strong>UserServiceDetail</strong></p><p>实现了<code>UserDetailsService</code>接口，所以需要实现唯一的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> zcs.oauthserver.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.authority.SimpleGrantedAuthority;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UsernameNotFoundException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> zcs.oauthserver.model.UserModel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceDetail</span> <span class="keyword">implements</span> <span class="title">UserDetailsService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String s)</span> <span class="keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line">        List&lt;SimpleGrantedAuthority&gt; authorities = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        authorities.add(<span class="keyword">new</span> SimpleGrantedAuthority(<span class="string">"ROLE"</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UserModel(<span class="string">"user"</span>,<span class="string">"user"</span>,authorities);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="red">这里先用假参数实现功能，后面添加数据库</font></p><p>参数s是前端输入的用户名，通过该参数查找数据库，获取密码和角色权限，最后将这三个数据封装到<code>UserDetails</code>接口的实现类中返回。这里封装的类可以使用<code>org.springframework.security.core.userdetails.User</code>或者自己实现<code>UserDetails</code>接口。</p><p><strong>UserModel</strong></p><p>实现<code>UserDetails</code>接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> zcs.oauthserver.model;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.GrantedAuthority;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.authority.SimpleGrantedAuthority;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserModel</span> <span class="keyword">implements</span> <span class="title">UserDetails</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;SimpleGrantedAuthority&gt; authorities;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserModel</span><span class="params">(String userName, String password, List&lt;SimpleGrantedAuthority&gt; authorities)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userName = userName;</span><br><span class="line">        <span class="keyword">this</span>.password = <span class="keyword">new</span> BCryptPasswordEncoder().encode(password);;</span><br><span class="line">        <span class="keyword">this</span>.authorities = authorities;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123;</span><br><span class="line">        <span class="keyword">return</span> authorities;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAccountNonExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAccountNonLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCredentialsNonExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新增username、password和authorities，最后一个存储的是该用户的权限列表，也就是用户拥有能够访问哪些资源的权限。<strong>密码加盐处理</strong>。</p><h3 id="配置Oauth2认证服务器"><a href="#配置Oauth2认证服务器" class="headerlink" title="配置Oauth2认证服务器"></a>配置Oauth2认证服务器</h3><p>新建配置类AuthorizationServerConfig 继承 AuthorizationServerConfigurerAdapter，并添加@Configuration<br>@EnableAuthorizationServer注解表明是一个认证服务器</p><p>重写三个函数</p><ul><li><code>ClientDetailsServiceConfigurer</code>：用来配置客户端详情服务，客户端详情信息在这里进行初始化，你能够把客户端详情信息写死在这里或者是通过数据库来存储调取详情信息。客户端就是指第三方应用</li><li><code>AuthorizationServerSecurityConfigurer</code>：用来配置令牌端点(Token Endpoint)的安全约束.</li><li><code>AuthorizationServerEndpointsConfigurer</code>：用来配置授权（authorization）以及令牌（token）的访问端点和令牌服务(token services)。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAuthorizationServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthorizationServerConfig</span> <span class="keyword">extends</span> <span class="title">AuthorizationServerConfigurerAdapter</span> </span>&#123;</span><br><span class="line"><span class="comment">//从WebSecurityConfig加载</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationManager authenticationManager;</span><br><span class="line">    <span class="comment">//内存存储令牌</span></span><br><span class="line">    <span class="keyword">private</span> TokenStore tokenStore = <span class="keyword">new</span> InMemoryTokenStore();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置客户端详细信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clients</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(ClientDetailsServiceConfigurer clients)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        clients.inMemory()</span><br><span class="line">            <span class="comment">//客户端ID</span></span><br><span class="line">                .withClient(<span class="string">"zcs"</span>)</span><br><span class="line">                .secret(<span class="keyword">new</span> BCryptPasswordEncoder().encode(<span class="string">"zcs"</span>))</span><br><span class="line">                <span class="comment">//权限范围</span></span><br><span class="line">                .scopes(<span class="string">"app"</span>)</span><br><span class="line">            <span class="comment">//授权码模式</span></span><br><span class="line">                .authorizedGrantTypes(<span class="string">"authorization_code"</span>)</span><br><span class="line">                <span class="comment">//随便写</span></span><br><span class="line">                .redirectUris(<span class="string">"www.baidu.com"</span>);</span><br><span class="line"><span class="comment">//        clients.withClientDetails(new JdbcClientDetailsService(dataSource));</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthorizationServerEndpointsConfigurer endpoints)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        endpoints.tokenStore(tokenStore)</span><br><span class="line">                .authenticationManager(authenticationManager);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在令牌端点定义安全约束</span></span><br><span class="line"><span class="comment">     * 允许表单验证，浏览器直接发送post请求即可获取tocken</span></span><br><span class="line"><span class="comment">     * 这部分写这样就行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> security</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthorizationServerSecurityConfigurer security)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        security</span><br><span class="line">                <span class="comment">// 开启/oauth/token_key验证端口无权限访问</span></span><br><span class="line">                .tokenKeyAccess(<span class="string">"permitAll()"</span>)</span><br><span class="line">                <span class="comment">// 开启/oauth/check_token验证端口认证权限访问</span></span><br><span class="line">                .checkTokenAccess(<span class="string">"isAuthenticated()"</span>)</span><br><span class="line">                .allowFormAuthenticationForClients();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端详细信息同样也是测试用，后续会加上数据库。令牌服务暂时是用内存存储，后续加上jwt。</p><p>先实现功能最重要，复杂的东西一步步往上加。</p><h3 id="配置资源服务器"><a href="#配置资源服务器" class="headerlink" title="配置资源服务器"></a>配置资源服务器</h3><p>资源服务器也就是服务程序，是需要访问的服务器</p><p>新建ResourceServerConfig继承ResourceServerConfigurerAdapter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableResourceServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceServerConfig</span> <span class="keyword">extends</span> <span class="title">ResourceServerConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http</span><br><span class="line"><span class="comment">//                antMatcher表示只能处理/user的请求</span></span><br><span class="line">                .antMatcher(<span class="string">"/user/**"</span>)</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="string">"/user/test1"</span>).permitAll()</span><br><span class="line">                .antMatchers(<span class="string">"/user/test2"</span>).authenticated()</span><br><span class="line"><span class="comment">//                .antMatchers("user/test2").hasRole("USER")</span></span><br><span class="line"><span class="comment">//                .anyRequest().authenticated()</span></span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ResourceServerConfigurerAdapter</code>的Order默认值是3，小于<code>WebSecurityConfigurerAdapter</code>，值越小优先级越大</p><p>关于<code>ResourceServerConfigurerAdapter</code>和<code>WebSecurityConfigurerAdapter</code>的详细说明见</p><p><a href="https://www.jianshu.com/p/fe1194ca8ecd" target="_blank" rel="noopener">https://www.jianshu.com/p/fe1194ca8ecd</a></p><p>新建UserController</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/user/me"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Principal <span class="title">user</span><span class="params">(Principal principal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> principal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/user/test1"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"test1"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/user/test2"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"test2"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ol><li>获取code<br>浏览器访问<code>http://127.0.0.1:9120/oauth/authorize?client_id=zcs&amp;response_type=code&amp;redirect_uri=www.baidu.com</code>，然后跳出登陆页面，<br><img src="//zheyday.github.io/2019/10/07/SpringCloud-OAuth2和JWT/1570432456538.png" alt="1570432456538"></li></ol><p>登陆</p><p>认证</p><p><img src="//zheyday.github.io/2019/10/07/SpringCloud-OAuth2和JWT/1570442575560.png" alt="1570442575560"></p><p>地址栏会出现回调页面，并且带有code参数  <code>http://127.0.0.1:9120/oauth/www.baidu.com?code=FGQ1jg</code></p><ol start="2"><li>获取token<br>postman访问<code>http://127.0.0.1:9120/oauth/token?code=FGQ1jg&amp;grant_type=authorization_code&amp;redirect_uri=www.baidu.com&amp;client_id=zcs&amp;client_secret=zcs</code>，code填写刚才得到的code，使用POST请求</li></ol><p><img src="//zheyday.github.io/2019/10/07/SpringCloud-OAuth2和JWT/1570442089823.png" alt="1570442089823"></p><ol start="3"><li>访问资源<br>/user/test2是受保护资源，我们通过令牌访问<br><img src="//zheyday.github.io/2019/10/07/SpringCloud-OAuth2和JWT/1570442119823.png" alt="1570442119823"></li></ol><h2 id="二、升级版"><a href="#二、升级版" class="headerlink" title="二、升级版"></a>二、升级版</h2><h3 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h3><p>有很多人会把JWT和OAuth2来作比较，其实它俩是完全不同的概念，没有可比性。</p><p>JWT是一种认证协议，提供一种用于发布接入令牌、并对发布的签名接入令牌进行验证的方法。</p><p>OAuth2是一种授权框架，提供一套详细的授权机制。</p><p>Spring Cloud OAuth2集成了JWT作为令牌管理，因此使用起来很方便</p><p><code>JwtAccessTokenConverter</code>是用来生成token的转换器，而token令牌默认是有签名的，且资源服务器需要验证这个签名。此处的加密及验签包括两种方式：<br>对称加密、非对称加密（公钥密钥）<br>对称加密需要授权服务器和资源服务器存储同一key值，而非对称加密可使用密钥加密，暴露公钥给资源服务器验签，本文中使用非对称加密方式。</p><p>通过jdk工具生成jks证书，通过cmd进入jdk安装目录的bin下，运行命令</p><p><code>keytool -genkeypair -alias oauth2-keyalg RSA -keypass mypass -keystore oauth2.jks -storepass mypass</code></p><p>会在当前目录生成oauth2.jks文件，放入resource目录下。</p><p>maven默认不加载resource目录下的文件，所以需要在pom.xml中配置，在build下添加配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.*<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在原来的AuthorizationServerConfig中更改部分代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TokenStore tokenStore;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthorizationServerEndpointsConfigurer endpoints)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//        endpoints.tokenStore(tokenStore)</span></span><br><span class="line"><span class="comment">//                .authenticationManager(authenticationManager);</span></span><br><span class="line">        endpoints.authenticationManager(authenticationManager)</span><br><span class="line">                .accessTokenConverter(jwtAccessTokenConverter())</span><br><span class="line">                .tokenStore(tokenStore);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TokenStore <span class="title">tokenStore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JwtTokenStore(jwtAccessTokenConverter());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 非对称加密算法对token进行签名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JwtAccessTokenConverter <span class="title">jwtAccessTokenConverter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> JwtAccessTokenConverter converter = <span class="keyword">new</span> CustomJwtAccessTokenConverter();</span><br><span class="line">        <span class="comment">// 导入证书</span></span><br><span class="line">        KeyStoreKeyFactory keyStoreKeyFactory =</span><br><span class="line">                <span class="keyword">new</span> KeyStoreKeyFactory(<span class="keyword">new</span> ClassPathResource(<span class="string">"oauth2.jks"</span>), <span class="string">"mypass"</span>.toCharArray());</span><br><span class="line">        converter.setKeyPair(keyStoreKeyFactory.getKeyPair(<span class="string">"oauth2"</span>));</span><br><span class="line">        <span class="keyword">return</span> converter;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>jwtAccessTokenConverter</code>方法中有一个<code>CustomJwtAccessTokenConverter</code>类，这是继承了<code>JwtAccessTokenConverter</code>，自定义添加了额外的token信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义添加额外token信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomJwtAccessTokenConverter</span> <span class="keyword">extends</span> <span class="title">JwtAccessTokenConverter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> OAuth2AccessToken <span class="title">enhance</span><span class="params">(OAuth2AccessToken accessToken, OAuth2Authentication authentication)</span> </span>&#123;</span><br><span class="line">        DefaultOAuth2AccessToken defaultOAuth2AccessToken = <span class="keyword">new</span> DefaultOAuth2AccessToken(accessToken);</span><br><span class="line">        Map&lt;String, Object&gt; additionalInfo = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        UserModel user = (UserModel)authentication.getPrincipal();</span><br><span class="line">        additionalInfo.put(<span class="string">"USER"</span>,user);</span><br><span class="line">        defaultOAuth2AccessToken.setAdditionalInformation(additionalInfo);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.enhance(defaultOAuth2AccessToken,authentication);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h3><p>之前登陆是用假数据，现在通过连接数据库进行验证。</p><p>建立三个表，user存储用户账号和密码，role存储角色，user_role存储用户的角色</p><img src="/2019/10/07/SpringCloud-OAuth2和JWT/1570598886447.png"><p>user表</p><img src="/2019/10/07/SpringCloud-OAuth2和JWT/1570598990454.png"><p>role表</p><img src="/2019/10/07/SpringCloud-OAuth2和JWT/1570598945536.png"><p>user_role表</p><img src="/2019/10/07/SpringCloud-OAuth2和JWT/1570598962212.png"><p>使用mybatis-plus生成代码，改造之前的<code>UserServiceDetail</code>和<code>UserModel</code></p><img src="/2019/10/07/SpringCloud-OAuth2和JWT/1570598325161.png"><p>UserServiceDetail</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceDetail</span> <span class="keyword">implements</span> <span class="title">UserDetailsService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserMapper userMapper;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RoleMapper roleMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceDetail</span><span class="params">(UserMapper userMapper, RoleMapper roleMapper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userMapper = userMapper;</span><br><span class="line">        <span class="keyword">this</span>.roleMapper = roleMapper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String s)</span> <span class="keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line">        QueryWrapper&lt;User&gt; userQueryWrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">        userQueryWrapper.eq(<span class="string">"username"</span>, s);</span><br><span class="line">        User user = userMapper.selectOne(userQueryWrapper);</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"用户名或密码错误"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        user.setAuthorities(roleMapper.selectByUserId(user.getId()));</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过UserMapper查询用户信息，然后封装到User中，在自动生成的User上实现UserDetails接口</p><p>User</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span>, <span class="title">UserDetails</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableId</span>(value = <span class="string">"id"</span>, type = IdType.AUTO)</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableId</span>(value = <span class="string">"username"</span>)</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableId</span>(value = <span class="string">"password"</span>)</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableField</span>(exist = <span class="keyword">false</span>)</span><br><span class="line">    <span class="keyword">private</span> List&lt;Role&gt; authorities;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = <span class="keyword">new</span> BCryptPasswordEncoder().encode(password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAuthorities</span><span class="params">(List&lt;Role&gt; authorities)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.authorities = authorities;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAccountNonExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAccountNonLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCredentialsNonExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123;</span><br><span class="line">        <span class="keyword">return</span> authorities;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", username="</span> + username +</span><br><span class="line">                <span class="string">", password="</span> + password +</span><br><span class="line">                <span class="string">"&#125;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释说明：</strong></p><p>UserDetails中需要重写一个方法，是存储用户权限的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Collection&lt;? extends GrantedAuthority&gt; getAuthorities()</span><br></pre></td></tr></table></figure><p>所以新增了一个变量，并且打上注解表示这不是一个字段属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableField</span>(exist = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">private</span> List&lt;Role&gt; authorities;</span><br></pre></td></tr></table></figure><p>在Role上实现GrantedAuthority接口，只需要权限名称就可以了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Role</span> <span class="keyword">implements</span> <span class="title">Serializable</span>, <span class="title">GrantedAuthority</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAuthority</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在RoleMapper.java中新增方法，通过用户id查询拥有的角色</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select</span>(<span class="string">"select name from role r INNER JOIN user_role ur on ur.user_id=1 and ur.role_id=r.id"</span>)</span><br><span class="line"> <span class="function">List&lt;Role&gt; <span class="title">selectByUserId</span><span class="params">(Integer id)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><p>测试方法和第一部分一样，获取令牌的时候返回如下</p><img src="/2019/10/07/SpringCloud-OAuth2和JWT/1570459537790.png"><p><img src="//zheyday.github.io/2019/10/07/SpringCloud-OAuth2和JWT/1570459537790.png" alt="1570459537790"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;搭建一个oauth2服务器，包括认证、授权和资源服务器&lt;/p&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/zheyday/SpringCloudStudy&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://gith</summary>
      
    
    
    
    
    <category term="SpringCloud" scheme="https://zheyday.github.io/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud：Config</title>
    <link href="https://zheyday.github.io/2019/10/07/SpringCloud-Config/"/>
    <id>https://zheyday.github.io/2019/10/07/SpringCloud-Config/</id>
    <published>2019-10-07T10:12:07.000Z</published>
    <updated>2020-05-09T06:17:27.030Z</updated>
    
    <content type="html"><![CDATA[<p>Spring Cloud Config用来为分布式和微服务应用提供集中化的配置支持，分为服务端和客户端。服务端是一个独立的微服务应用，用来连接仓库并为客户端提供配置信息；客户端则是微服务架构中的各个服务，通过指定的配置中心来管理配置内容，并在启动的时候从配置中心加载配置信息。</p><h2 id="准备配置仓库"><a href="#准备配置仓库" class="headerlink" title="准备配置仓库"></a>准备配置仓库</h2><p>直接在之前的项目中新建config-reposity文件夹，并创建config-client子文件夹，等所有创建完成之后直接commit到仓库</p><p>假设需要读取配置的服务名称叫config-client，创建config-client-dev.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8620</span></span><br><span class="line"><span class="attr">env:</span> <span class="number">456</span></span><br></pre></td></tr></table></figure><h2 id="创建服务端"><a href="#创建服务端" class="headerlink" title="创建服务端"></a>创建服务端</h2><p>新建一个Module，用Spring Initializr创建一个Spring Cloud Config项目，勾选Config Server以及Discovery中的eureka client</p><p><img src="//zheyday.github.io/2019/10/07/SpringCloud-Config/1570331565204.png" alt="1570331565204"></p><p><img src="//zheyday.github.io/2019/10/07/SpringCloud-Config/1570331650276.png" alt="1570331650276"></p><p>在主类上添加@EnableConfigServer注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigServerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConfigServerApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在application.yml中添加配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8610</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">config-server</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">server:</span></span><br><span class="line">        <span class="attr">git:</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">https://github.com/zheyday/CloudOneConfig/</span></span><br><span class="line">          <span class="comment"># 如果是私有仓库 需要用户名和密码</span></span><br><span class="line">          <span class="attr">username:</span> <span class="string">zheyday</span></span><br><span class="line">          <span class="attr">password:</span> </span><br><span class="line">          <span class="attr">search-paths:</span> <span class="string">config-reposity/**</span></span><br><span class="line"><span class="comment">#注册到eureka-server</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:8761/eureka/</span></span><br></pre></td></tr></table></figure><p>uri是本项目的仓库地址</p><p>如果这个仓库是私有的，那么就需要填写<code>username</code>和<code>password</code></p><p>search-paths是搜索的路径，我们在开头创建了config-reposity文件夹，通常一个文件夹对应一个服务配置，所以要加/**表示所有路径</p><p>到这里配置中心就完成了。</p><p>完成了这些准备工作之后，我们就可以通过浏览器、POSTMAN直接来访问到我们的配置内容了。访问配置信息的URL与配置文件的映射关系如下：</p><ul><li>/{application}/{profile}[/{label}]</li><li>/{application}-{profile}.yml</li><li>/{label}/{application}-{profile}.yml</li><li>/{application}-{profile}.properties</li><li>/{label}/{application}-{profile}.properties</li></ul><p>上面的url会映射<code>{application}-{profile}.properties</code>对应的配置文件，其中<code>{label}</code>对应Git上不同的分支，默认为master。我们可以尝试构造不同的url来访问不同的配置内容，比如，要访问master分支，config-client应用的dev环境，就可以访问这个url：<code>http://localhost:8710/config-client/dev/master</code></p><h2 id="创建客户端"><a href="#创建客户端" class="headerlink" title="创建客户端"></a>创建客户端</h2><p>同创建服务端一样，只不过这里勾选config client</p><p>主类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigClientApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;env&#125;"</span>)</span><br><span class="line">    String info;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/hi"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hi</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInfo</span><span class="params">(String info)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.info = info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConfigClientApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建bootstrap.yml，来指定获取配置文件的git位置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">label:</span> <span class="string">master</span></span><br><span class="line">      <span class="attr">profile:</span> <span class="string">dev</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="comment">#开启通过服务从配置中心读取文件</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">service-id:</span> <span class="string">config-server</span></span><br><span class="line">      <span class="attr">fail-fast:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">config-client</span></span><br></pre></td></tr></table></figure><p>注意：必须使用bootstrap来指定，因为bootstrap要比application先加载</p><ul><li>spring.application.name：对应配置文件规则中的<code>{application}</code>部分</li><li>spring.cloud.config.profile：对应配置文件规则中的<code>{profile}</code>部分</li><li>spring.cloud.config.label：对应配置文件规则中的<code>{label}</code>部分</li><li>spring.cloud.config.discovery.service-id: 配置中心<code>config-server</code>的名称</li></ul><p>启动服务端和客户端</p><p>通过postman访问<a href="http://localhost:8620/hi" target="_blank" rel="noopener">http://localhost:8620/hi</a></p><p><img src="//zheyday.github.io/2019/10/07/SpringCloud-Config/1570333609797.png" alt="1570333609797"></p><p>可以看到，配置文件中的env已经加载到程序中</p><p>客户端也注册到了服务中心。端口号8620</p><img src="/2019/10/07/SpringCloud-Config/1570333676491.png"><p><img src="//zheyday.github.io/2019/10/07/SpringCloud-Config/1570333676491.png" alt="1570333676491"></p><h2 id="动态刷新"><a href="#动态刷新" class="headerlink" title="动态刷新"></a>动态刷新</h2><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--        动态刷新依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bus-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>application.yml添加</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">"*"</span></span><br></pre></td></tr></table></figure><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--        动态刷新依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bus-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>config-client-dev.yml新增</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">guest</span></span><br></pre></td></tr></table></figure><p>在需要动态更新的类上加<code>@RefreshScope</code>注解，这里在主类上添加</p><p>postman通过POST方式访问<a href="http://localhost:8610/actuator/bus-refresh进行刷新。" target="_blank" rel="noopener">http://localhost:8610/actuator/bus-refresh进行刷新。</a></p><h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>为了启用该功能，我们需要在配置中心的运行环境中安装不限长度的JCE版本（Unlimited Strength Java Cryptography Extension）。虽然，JCE功能在JRE中自带，但是默认使用的是有长度限制的版本。我们可以从Oracle的官方网站中下载到它，它是一个压缩包，解压后可以看到下面三个文件：</p><p><code>README.txtlocal_policy.jarUS_export_policy.jar</code></p><p>我们需要将<code>local_policy.jar</code>和<code>US_export_policy.jar</code>两个文件复制到<code>$JAVA_HOME/jre/lib/security</code>目录下，覆盖原来的默认内容。到这里，加密解密的准备工作就完成了。</p><h3 id="相关端点"><a href="#相关端点" class="headerlink" title="相关端点"></a>相关端点</h3><ul><li><code>/encrypt/status</code>：查看加密功能状态的端点</li><li><code>/key</code>：查看密钥的端点</li><li><code>/encrypt</code>：对请求的body内容进行加密的端点</li><li><code>/decrypt</code>：对请求的body内容进行解密的端点</li></ul><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>首先，我们需要通过<code>keytool</code>工具来生成密钥对。<code>keytool</code>是JDK中的一个密钥和证书管理工具。它使用户能够管理自己的公钥/私钥对及相关证书，用于（通过数字签名）自我认证（用户向别的用户/服务认证自己）或数据完整性以及认证服务。在JDK 1.4以后的版本中都包含了这一工具，它的位置在：<code>%JAVA_HOME%\bin\keytool.exe</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ keytool -genkeypair -alias config-server -keyalg RSA \ </span><br><span class="line">  -dname "CN=zhaiyongchao, OU=company, O=organization, L=city, ST=province, C=china" \</span><br><span class="line">  -keypass 222222 \</span><br><span class="line">  -keystore config-server.keystore \</span><br><span class="line">  -storepass 111111 \</span><br><span class="line">  -validity 3650 \</span><br></pre></td></tr></table></figure><p>keypass是私钥</p><p>storepass是秘钥</p><p>执行完之后会在当前文件夹生成config-server.keystore文件，将其复制到服务端工程的resources下，并且新建bootstrap.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">encrypt:</span></span><br><span class="line">  <span class="attr">key-store:</span></span><br><span class="line">    <span class="attr">location:</span> <span class="string">config-server.keystore</span></span><br><span class="line">    <span class="attr">alias:</span> <span class="string">config-server</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">secret:</span> <span class="number">123456</span></span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>命令行输入</p><p>curl  <a href="http://localhost:8610/encrypt" target="_blank" rel="noopener">http://localhost:8610/encrypt</a> -d 123</p><p>得到一长串字符，这就是加密后的结果。将其复制到配置文件中，如下格式：</p><p><code>env:&#39;{cipher}asldkfjalskdfja&#39;</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Spring Cloud Config用来为分布式和微服务应用提供集中化的配置支持，分为服务端和客户端。服务端是一个独立的微服务应用，用来连接仓库并为客户端提供配置信息；客户端则是微服务架构中的各个服务，通过指定的配置中心来管理配置内容，并在启动的时候从配置中心加载配置信息</summary>
      
    
    
    
    
    <category term="SpringCloud" scheme="https://zheyday.github.io/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud Zuul整合Swagger2</title>
    <link href="https://zheyday.github.io/2019/09/30/SpringCloud-Zuul%E6%95%B4%E5%90%88Swagger2/"/>
    <id>https://zheyday.github.io/2019/09/30/SpringCloud-Zuul%E6%95%B4%E5%90%88Swagger2/</id>
    <published>2019-09-30T11:13:28.000Z</published>
    <updated>2019-09-30T11:48:04.011Z</updated>
    
    <content type="html"><![CDATA[<p>Swagger可以为Spring MVC中的接口生成文档，但是微服务化后API都散落在各个微服务中，该如何生成API文档呢？既然需要集中生成，那么自然想到通过Zuul来实现这个功能。</p><h2 id="Service模块"><a href="#Service模块" class="headerlink" title="Service模块"></a>Service模块</h2><p>对之前建立的eureka-client进行改造。</p><p>引入swagger依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.spring4all<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>swagger-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在controller上添加<code>@EnableSwagger2Doc</code>注解，在具体方法上添加相应注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiOperation</span>(value = <span class="string">"获取端口号"</span>,notes = <span class="string">"."</span>)</span><br><span class="line"><span class="meta">@ApiImplicitParam</span>(name = <span class="string">"name"</span>,value = <span class="string">"用户名"</span>,required = <span class="keyword">true</span>,dataType = <span class="string">"String"</span>)</span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/hi"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">dc</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello"</span> + name + <span class="string">" i am from "</span> + port;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@ApiOperation</code>：说明方法的作用</p><p><code>@ApiImplicitParam</code>：解释参数。当有多个参数时，需要使用<code>@ApiImplicitParams</code>({})</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@ApiOperation(value = <span class="string">"用户登陆"</span>, notes = <span class="string">"."</span>)</span><br><span class="line">   @ApiImplicitParams(&#123;</span><br><span class="line">           @ApiImplicitParam(name = <span class="string">"name"</span>, value = <span class="string">"用户名"</span>, required = <span class="literal">true</span>, dataType = <span class="string">"String"</span>),</span><br><span class="line">           @ApiImplicitParam(name = <span class="string">"psd"</span>, value = <span class="string">"密码"</span>, required = <span class="literal">true</span>, dataType = <span class="string">"String"</span>)</span><br><span class="line">   &#125;)</span><br><span class="line">   @PostMapping(<span class="string">"/login"</span>)</span><br><span class="line">   public <span class="built_in">String</span> login(<span class="built_in">String</span> name, <span class="built_in">String</span> psd) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">"hello"</span> + name + <span class="string">" i am from "</span> + port;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>application.yml中也有一些配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">swagger:</span><br><span class="line">  base-package: zcs.user_center.controller</span><br><span class="line">  title: 用户中心接口文档</span><br></pre></td></tr></table></figure><p><code>base-package</code>表示需要扫描的包，也就是在这个包下的类才会生成API文档。默认是全部</p><p><code>title</code>表示该文档的标题</p><h2 id="Zuul模块"><a href="#Zuul模块" class="headerlink" title="Zuul模块"></a>Zuul模块</h2><p>新建一个Spring模块，引入jar包。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.spring4all<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>swagger-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-zuul<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>application.yml配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">zuul:</span><br><span class="line">  routes:</span><br><span class="line">    eureka-client: /eureka-client/**</span><br><span class="line">    user-center: /user-center/**</span><br><span class="line">swagger:</span><br><span class="line">  title: SpringCloud项目开发文档</span><br><span class="line">  description: 秒杀/12306</span><br><span class="line">  version: 1.0</span><br></pre></td></tr></table></figure><p><code>zuul.routes</code>表示zuul需要拦截的请求，这里配置两个路径。</p><p>Application类中新增</p><pre><code>@ConfigurationProperties(&quot;zuul&quot;)public ZuulProperties zuulProperties() {    return new ZuulProperties();}</code></pre><p>表示从yml中获取配置。</p><p>新建一个swagger配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> zcs.apigateway.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.spring4all.swagger.EnableSwagger2Doc;</span><br><span class="line"><span class="keyword">import</span> io.swagger.models.Swagger;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.zuul.filters.ZuulProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Primary;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.swagger.web.SwaggerResource;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.swagger.web.SwaggerResourcesProvider;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableSwagger</span>2Doc</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Swagger2</span> <span class="keyword">implements</span> <span class="title">SwaggerResourcesProvider</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ZuulProperties zuulProperties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;SwaggerResource&gt; <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; routeList=zuulProperties.getRoutes().keySet();</span><br><span class="line">        List&lt;SwaggerResource&gt; resources = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s : routeList) &#123;</span><br><span class="line">            resources.add(swaggerResource(s,<span class="string">"/"</span>+s+<span class="string">"/v2/api-docs"</span>,<span class="string">"2.0"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resources;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> SwaggerResource <span class="title">swaggerResource</span><span class="params">(String name,String location,String version)</span></span>&#123;</span><br><span class="line">        SwaggerResource swaggerResource=<span class="keyword">new</span> SwaggerResource();</span><br><span class="line">        swaggerResource.setName(name);</span><br><span class="line">        swaggerResource.setLocation(location);</span><br><span class="line">        swaggerResource.setSwaggerVersion(version);</span><br><span class="line">        <span class="keyword">return</span> swaggerResource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>routeList</code>中包含yml中所有的路径。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>启动两个服务和网关服务，访问http:localhost:9110/swagger-ui.html</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Swagger可以为Spring MVC中的接口生成文档，但是微服务化后API都散落在各个微服务中，该如何生成API文档呢？既然需要集中生成，那么自然想到通过Zuul来实现这个功能。&lt;/p&gt;
&lt;h2 id=&quot;Service模块&quot;&gt;&lt;a href=&quot;#Service模块&quot; c</summary>
      
    
    
    
    
    <category term="SpringCloud" scheme="https://zheyday.github.io/tags/SpringCloud/"/>
    
    <category term="Restful" scheme="https://zheyday.github.io/tags/Restful/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode--Dynamic Programming</title>
    <link href="https://zheyday.github.io/2019/09/25/LeetCode-Dynamic-Programming/"/>
    <id>https://zheyday.github.io/2019/09/25/LeetCode-Dynamic-Programming/</id>
    <published>2019-09-25T12:54:46.000Z</published>
    <updated>2019-09-25T13:09:36.794Z</updated>
    
    
    
    
    <category term="Dynamic Programming" scheme="https://zheyday.github.io/categories/Dynamic-Programming/"/>
    
    
    <category term="LeetCode" scheme="https://zheyday.github.io/tags/LeetCode/"/>
    
    <category term="Dynamic Programming" scheme="https://zheyday.github.io/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>Spring框架学习(一)：Ioc</title>
    <link href="https://zheyday.github.io/2019/09/24/Spring-IoC/"/>
    <id>https://zheyday.github.io/2019/09/24/Spring-IoC/</id>
    <published>2019-09-24T08:58:23.000Z</published>
    <updated>2020-06-26T11:28:29.213Z</updated>
    
    <content type="html"><![CDATA[<p>对tiny-spring项目的学习，转载自黄亿华大佬的&lt;&lt;1000行代码读懂Spring（一）- 实现一个基本的IoC容器&gt;&gt;。</p><p>原网址：</p><p><a href="http://my.oschina.net/flashsword/blog/192551" target="_blank" rel="noopener">http://my.oschina.net/flashsword/blog/192551</a></p><p><a href="https://my.oschina.net/flashsword/blog/194481" target="_blank" rel="noopener">https://my.oschina.net/flashsword/blog/194481</a></p><p>概念的讲解转自 <a href="https://blog.csdn.net/Tritoy/article/details/81010595" target="_blank" rel="noopener">https://blog.csdn.net/Tritoy/article/details/81010595</a></p><h1 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h1><h2 id="什么是IOC？"><a href="#什么是IOC？" class="headerlink" title="什么是IOC？"></a>什么是IOC？</h2><p>来自知乎：<a href="https://www.zhihu.com/question/23277575/answer/24259844" target="_blank" rel="noopener">https://www.zhihu.com/question/23277575/answer/24259844</a></p><p>Inversion of Control，即控制反转，是一种设计思想。</p><p>传统程序设计中，创建对象的主动权是由自己把控的；现在由Spring的IoC容器根据配置文件来创建及注入依赖对象，而不是由对象主动去找。</p><h2 id="什么是DI？"><a href="#什么是DI？" class="headerlink" title="什么是DI？"></a>什么是DI？</h2><p>Dependency Injection，即依赖注入，和IOC是同一个概念不同角度的描述。组件之间的依赖关系由容器在运行期决定，由容器动态的将依赖关系注入到组件之中。DI的目的是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。</p><h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><h3 id="IOC-1"><a href="#IOC-1" class="headerlink" title="IOC"></a>IOC</h3><p>找女朋友一般情况就是到处去看哪里有符合自己审美的，然后打听她们的兴趣爱好、电话等等。传统程序开发也是如此，在一个对象中，如果要使用其他的对象，我们需要手动new一个。</p><p>Ioc相当于一个婚恋平台，你只需要告诉它们你的要求，然后它们会根据要求给你提供一个女朋友，整个过程都是由平台来控制。Spring的开发方式也是如此。所有的类都会在容器中登记，告诉spring它是什么，需要什么，然后spring会在运行到适当的时候把你要的东西给你，同时也把你给其他需要你的东西。所有类的创建、销毁都有spring控制。以前是对象控制其他对象，现在是spring控制所有对象，所以叫控制反转。</p><h3 id="DI"><a href="#DI" class="headerlink" title="DI"></a>DI</h3><p>IoC的一个重点就是在系统运行中，动态的向某个对象提供它所需要的其他对象，这就是通过DI实现的。</p><p>比如对象A需要操作数据库，以前我们是自己编码获取一个Connction对象，现在我们只需要告诉spring，A中需要一个Connection，至于Connection怎么构造、何时构造我们都不需要知道。spring会在适当的时候向A注射一个Connection，这就是依赖注入。</p><h2 id="tiny-spring分析"><a href="#tiny-spring分析" class="headerlink" title="tiny-spring分析"></a>tiny-spring分析</h2><p>克隆项目到本地</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:<span class="comment">//github.com/code4craft/tiny-spring.git</span></span><br></pre></td></tr></table></figure><p>我在原来项目的基础上添加了一些中文注释，github项目地址：<a href="https://github.com/zcsherrydc/zcs-spring.git" target="_blank" rel="noopener">https://github.com/zcsherrydc/zcs-spring.git</a></p><p>每一步的命令需要更改为对应的序号，如第一步就是step1，第二步就是step2</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout origin/step1</span><br></pre></td></tr></table></figure><h3 id="step1-最基本的容器"><a href="#step1-最基本的容器" class="headerlink" title="step1-最基本的容器"></a>step1-最基本的容器</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout step<span class="number">-1</span>-container-register-and-<span class="keyword">get</span></span><br></pre></td></tr></table></figure><p>IoC最基本的角色有两个：容器（BeanFactory）和Bean本身。<code>BeanDefinition</code>封装了Bean对象。</p><p><img src="//zheyday.github.io/2019/09/24/Spring-IoC/1569327273103.png" alt="1569327273103"></p><h3 id="step2-在工厂中创建bean"><a href="#step2-在工厂中创建bean" class="headerlink" title="step2-在工厂中创建bean"></a>step2-在工厂中创建bean</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout step<span class="number">-2</span>-abstract-beanfactory-and-<span class="keyword">do</span>-bean-initilizing-<span class="keyword">in</span>-it</span><br></pre></td></tr></table></figure><p>step1中的bean是初始化好之后再set进去的，实际使用中我们希望容器来管理bean的创建。为了方便扩展，抽象出BeanFactory接口和AbstractBeanFactory类。</p><p><img src="//zheyday.github.io/2019/09/24/Spring-IoC/image-20200325112410383.png" alt="image-20200325112410383"></p><p>AbstractBeanFactory里面最重要的是抽象方法<code>doCreateBean()</code>。通过反射获取bean的实例，放入BeanDefinition中，并注册到BeanFactory。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码与最终代码略有不同</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String name, BeanDefinition beanDefinition)</span> </span>&#123;</span><br><span class="line">        Object bean = doCreateBean(beanDefinition);</span><br><span class="line">        beanDefinition.setBean(bean);</span><br><span class="line">        beanDefinitionMap.put(name, beanDefinition);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//        初始化</span></span><br><span class="line">        BeanFactory beanFactory = <span class="keyword">new</span> AutowireCapable();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        注入bean</span></span><br><span class="line">        BeanDefinition beanDefinition = <span class="keyword">new</span> BeanDefinition();</span><br><span class="line">        beanDefinition.setBeanClassName(<span class="string">"zcs.ioc.HelloWorldService"</span>);</span><br><span class="line">        beanFactory.registerBeanDefinition(<span class="string">"helloWorldService"</span>,beanDefinition);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        获取bean</span></span><br><span class="line">        HelloWorldService helloWorldService= (HelloWorldService) beanFactory.getBean(<span class="string">"helloWorldService"</span>);</span><br><span class="line">        helloWorldService.helloWorld();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们需要给BeanFactory传入<code>完整类名</code>和<code>实例名称</code>。这些都可以通过xml文件获取，在step4中完成。还有一个问题就是现在是通过无参构造函数创建的对象，内部成员变量都是null，所以下一步是对成员变量赋值。</p><h3 id="step3-为bean注入属性"><a href="#step3-为bean注入属性" class="headerlink" title="step3-为bean注入属性"></a>step3-为bean注入属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout step-<span class="number">3</span>-inject-bean-with-property</span><br></pre></td></tr></table></figure><p>创建两个类，<code>PropertyValue</code>和<code>PropertyValues</code>，前者保存一个字段的名称和对应值，后者有一个集合保存了所有的<code>PropertyValue</code>。每个BeanDefinition有一个<code>PropertyValues</code>。</p><p><code>AutowireCapable</code>中新增属性注入方法。Spring使用setter进行注入，这里为了简单使用Field。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">applyPropertyValues</span><span class="params">(Object bean, BeanDefinition mbd)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (PropertyValue propertyValue : mbd.getPropertyValues().getPropertyValues()) &#123;</span><br><span class="line">            Field declaredField = bean.getClass().getDeclaredField(propertyValue.getName());</span><br><span class="line">            declaredField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            declaredField.set(bean, propertyValue.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>HelloWorldService新增text字段。</p><h3 id="step4-读取xml来初始化bean"><a href="#step4-读取xml来初始化bean" class="headerlink" title="step4-读取xml来初始化bean"></a>step4-读取xml来初始化bean</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout step-4-config-beanfactory-with-xml</span><br></pre></td></tr></table></figure><p>看一下文件结构：</p><p>Resource</p><table><thead><tr><th>类名</th><th>说明</th></tr></thead><tbody><tr><td>Resource</td><td>接口，通过<code>getInputStream()</code>获取资源的输入流</td></tr><tr><td>UrlResource</td><td>实现Resource接口，通过URL获取资源</td></tr><tr><td>ResourceLoader</td><td>资源加载类，通过getResource()获取一个Resource对象</td></tr></tbody></table><table><thead><tr><th>类名</th><th>说明</th></tr></thead><tbody><tr><td>BeanDefinition</td><td>Bean的包装类，包括Bean的名字、类型、属性键值对</td></tr><tr><td>BeanDefinitionReader</td><td>解析 <code>BeanDefinition</code> 的接口。通过 <code>loadBeanDefinitions(String)</code> 从一个地址来加载类定义。</td></tr><tr><td>AbstractBeanDefinitionReader</td><td>实现 <code>BeanDefinitionReader</code> 接口的抽象类</td></tr><tr><td>XmlBeanDefinitionReader</td><td>具体实现了 <code>loadBeanDefinitions()</code> 方法，从 XML 文件中读取类定义</td></tr></tbody></table><p>XmlBeanDefinitionReader负责读取xml，把<bean>标签封装成BeanDefinition注册到registry，之后把registry都注册到AutowireCapableBeanFactory中</bean></p><p><img src="//zheyday.github.io/2019/09/24/Spring-IoC/image-20200325134442636.png" alt="image-20200325134442636"></p><p>整个读取流程：</p><p><img src="//zheyday.github.io/2019/09/24/Spring-IoC/1569395793717.png" alt="1569395793717"></p><ol><li>new一个<code>ResourceLoader</code>放入<code>XmlBeanDefinition</code>中，通过<code>loadBeanDefinition</code>传入xml文件地址</li></ol><ul><li>获取xml文件的输入流</li><li>通过<code>DocumentBuilder</code>解析出<code>Document</code>。先获取所有的bean，然后根据bean名称和类名构建空实例，对当前的bean继续解析，根据<code>property</code>实现对bean属性的赋值</li></ul><ol start="2"><li>将解析好的bean注册到BeanFactory</li></ol><h3 id="step5-为bean注入bean"><a href="#step5-为bean注入bean" class="headerlink" title="step5-为bean注入bean"></a>step5-为bean注入bean</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout step-5-inject-bean-to-bean</span><br></pre></td></tr></table></figure><p>目前为止，我们只是处理了bean之间没有依赖的情况，还无法处理bean之间的依赖。</p><p>我们定义一个BeanReference来表示这个属性是对另一个Bean的引用。在<code>XMLBeanDefinition</code>的<code>processProperty</code>方法中加入判断。如果是ref，就new一个BeanReference封装到PropertyValue.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processProperty</span><span class="params">(Element ele, BeanDefinition beanDefinition)</span> </span>&#123;</span><br><span class="line">        NodeList propertyNode = ele.getElementsByTagName(<span class="string">"property"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; propertyNode.getLength(); i++) &#123;</span><br><span class="line">            Node node = propertyNode.item(i);</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">                Element propertyEle = (Element) node;</span><br><span class="line">                String name = propertyEle.getAttribute(<span class="string">"name"</span>);</span><br><span class="line">                String value = propertyEle.getAttribute(<span class="string">"value"</span>);</span><br><span class="line">                <span class="comment">//---------------新加入代码----------------------</span></span><br><span class="line"><span class="comment">//                name对应的是value</span></span><br><span class="line">                <span class="keyword">if</span> (value!=<span class="keyword">null</span> &amp;&amp; value.length()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                    beanDefinition.getPropertyValues().addPropertyValue(<span class="keyword">new</span> PropertyValue(name, value));</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//                    name对应的是ref</span></span><br><span class="line">                    String ref=propertyEle.getAttribute(<span class="string">"ref"</span>);</span><br><span class="line">                    <span class="keyword">if</span> (ref == <span class="keyword">null</span> || ref.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Configuration problem: &lt;property&gt; element for property '"</span></span><br><span class="line">                                + name + <span class="string">"' must specify a ref or value"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    BeanReference beanReference = <span class="keyword">new</span> BeanReference(ref);</span><br><span class="line">                    beanDefinition.getPropertyValues().addPropertyValue(<span class="keyword">new</span> PropertyValue(name, beanReference));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><img src="/2019/09/24/Spring-IoC/1569402791468.png"><p><img src="//zheyday.github.io/2019/09/24/Spring-IoC/1569402791468.png" alt="1569402791468"></p><p>解析完成之后，BeanFactory中只有&lt;String, BeanDefinition&gt;信息，并没有bean实例，即bean为null。</p><p>同时为了解决循环依赖的问题，我们使用懒加载的方式，即在需要使用的时候才创建。如果属性对应的bean找不到，那么就先创建。因为总是先创建后注入，所以不会存在循环依赖的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//        获取bean</span></span><br><span class="line">        HelloWorldService helloWorldService = (HelloWorldService) beanFactory.getBean(<span class="string">"helloWorldService"</span>);</span><br><span class="line">        helloWorldService.helloWorld();</span><br></pre></td></tr></table></figure><p>xml中的配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"helloWorldService"</span> <span class="attr">class</span>=<span class="string">"zcs.ioc.HelloWorldService"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">"Hello World!"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"outputService"</span> <span class="attr">ref</span>=<span class="string">"outputService"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"outputService"</span> <span class="attr">class</span>=<span class="string">"zcs.ioc.OutputService"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"helloWorldService"</span> <span class="attr">ref</span>=<span class="string">"helloWorldService"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="step6-ApplicationContext登场"><a href="#step6-ApplicationContext登场" class="headerlink" title="step6-ApplicationContext登场"></a>step6-ApplicationContext登场</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout step-6-invite-application-context</span><br></pre></td></tr></table></figure><p>现在功能差不多齐全了，但是使用起来比较麻烦，于是引入<code>ApplicationContext</code>接口，并在<code>refresh()</code>方法下进行bean的初始化。</p><p><img src="//zheyday.github.io/2019/09/24/Spring-IoC/1569404506979.png" alt="1569404506979"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String configLocation, AbstractBeanFactory beanFactory)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(beanFactory);</span><br><span class="line">        <span class="keyword">this</span>.configLocation = configLocation;</span><br><span class="line">        refresh();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>所以使用的时候只需要传入xml地址就可以了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ApplicationContext applicationContext=<span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"tinyioc.xml"</span>);</span><br><span class="line">        HelloWorldService helloWorldService = (HelloWorldService) applicationContext.getBean(<span class="string">"helloWorldService"</span>);</span><br><span class="line">        helloWorldService.helloWorld();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>至此为止，tiny-spring的IoC部分基本结束。</p><h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><h2 id="什么是AOP"><a href="#什么是AOP" class="headerlink" title="什么是AOP"></a>什么是AOP</h2><p>即面向切面编程，将分散在各个业务逻辑代码中相同的部分通过横向切割的方式提取到一个独立的模块中</p><p>比如日志记录、安全控制、事务处理、异常处理等</p><p><img src="//zheyday.github.io/2019/09/24/Spring-IoC/image-20200327095900404.png" alt="image-20200327095900404"></p><p>Spring Aop主要是通过动态代理实现的，先看一下代理的相关内容</p><h2 id="什么是代理"><a href="#什么是代理" class="headerlink" title="什么是代理"></a>什么是代理</h2><p>给目标对象提供一个代理对象，并由代理对象控制对目标对象的引用。</p><p>使用代理的最主要原因就是在不改变目标对象的情况下对方法进行增强。比如，增加日志等。</p><h3 id="举个栗子-1"><a href="#举个栗子-1" class="headerlink" title="举个栗子"></a>举个栗子</h3><p>有一个接口，只有hello的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IHello</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一个实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloImpl</span> <span class="keyword">implements</span> <span class="title">IHello</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在想在方法被调用的时候添加日志。如果直接在实现类上改，那么所有的实现类都需要改，显而易见，这是非常繁琐的一件事。当新增实现类时，也需要做这种繁琐重复的事情，代码可维护性极低。</p><p>那么该怎么才能一次性完成这项工作呢？这就需要代理了。</p><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>举个栗子理解一下</p><p>有一排瓶子放在那不动，任务是给每个瓶子贴上标签。</p><p>方法一：每次需要改标签你要自己一个个去贴。</p><p>方法二：现在有了流水线，你把之前贴标签的任务交给了流水线上的机器来做，只要往机器里输入标签内容，把需要改的瓶子放入流水线，出来的就是改过标签的瓶子了，这样就方便多了。</p><p>这里的瓶子就相当于实现类，静态代理就相当于方法二，代理类相当于流水线的机器，在代理类中进行方法的修改（比如添加日志）。只要将需要修改的实现类（委托类）传给代理类即可。</p><p><code>target</code>是需要修改的实现类，通过构造函数传入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloProxy</span> <span class="keyword">implements</span> <span class="title">IHello</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IHello target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloProxy</span><span class="params">(IHello target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"start"</span>);</span><br><span class="line">        target.hello();</span><br><span class="line">        System.out.println(<span class="string">"end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">       IHello hello=<span class="keyword">new</span> HelloImpl();</span><br><span class="line">       HelloProxy helloProxy=<span class="keyword">new</span> HelloProxy(hello);</span><br><span class="line">       helloProxy.hello();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><p><img src="//zheyday.github.io/2019/09/24/Spring-IoC/1571807561145.png" alt="1571807561145"></p><p><strong>优点</strong></p><p>客户端不需要知道实现类是什么，只需知道代理类即可</p><p><strong>缺点</strong></p><ul><li>代理类和实现类（委托类）实现了相同的接口，接口类每增加一个方法，代理类和实现类都需要实现，增加了维护的复杂度。例如想在每个方法都添加日志，那么代理类的每个实现方法也都要添加</li><li>一个代理类只对应一种接口，如果想对两个接口都添加日志，那么就需要两个代理类。静态代理只能为特定的接口服务</li></ul><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>在程序开发中，静态代理会产生许多代理类，所以就需要动态代理了。</p><p>动态代理是通过反射机制实现的，能够代理各种类型的对象。缺点：委托类一定要有接口</p><p>实现动态代理需要两个类：</p><ul><li>java.lang.reflect.InvocationHandler接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable</span>;</span><br></pre></td></tr></table></figure><p>该接口只有一个方法，代理类需要实现这个方法来实现方法的调用</p><ul><li><p>java.lang.reflect.Proxy类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          InvocationHandler h)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException</span></span><br></pre></td></tr></table></figure><p>通过该方法得到一个代理类对象</p></li></ul><p>代理类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//传入实现类的实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicProxy</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(),</span><br><span class="line">                target.getClass().getInterfaces(), <span class="keyword">new</span> InvocationHandler()&#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">"start"</span>);</span><br><span class="line">                        Object ret = method.invoke(target, args);</span><br><span class="line">                        System.out.println(<span class="string">"end"</span>);</span><br><span class="line">                        <span class="keyword">return</span> ret;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//        动态代理</span></span><br><span class="line">        DynamicProxy dynamicProxy = <span class="keyword">new</span> DynamicProxy(<span class="keyword">new</span> HelloImpl());</span><br><span class="line">        IHello hello1 = (IHello) dynamicProxy.getProxy();</span><br><span class="line">        hello1.hello();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="//zheyday.github.io/2019/09/24/Spring-IoC/1571816689909.png" alt="1571816689909"></p><p>细说一下底层实现原理，主要实现就是<code>newProxyInstance</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      InvocationHandler h)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Objects.requireNonNull(h);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class="line">    <span class="keyword">final</span> SecurityManager sm = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">        checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 生成代理类的class</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 使用我们实现的InvocationHandler作为参数调用构造方法来获得代理类的实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ```</span><br><span class="line">        <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">        ```</span><br><span class="line">        <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> Object[]&#123;h&#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要看一下<code>getProxyClass0</code>方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;</span><br><span class="line">        proxyClassCache = <span class="keyword">new</span> WeakCache&lt;&gt;(<span class="keyword">new</span> KeyFactory(), <span class="keyword">new</span> ProxyClassFactory());</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass0(ClassLoader loader,</span><br><span class="line">                                       Class&lt;?&gt;... interfaces) &#123;</span><br><span class="line">    <span class="keyword">if</span> (interfaces.length &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"interface limit exceeded"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对代理进行了缓存</span></span><br><span class="line">    <span class="keyword">return</span> proxyClassCache.get(loader, interfaces);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//get()方法里有一句是用来创建代理类的 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BiFunction&lt;K, P, ?&gt; subKeyFactory;</span><br><span class="line">Object subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter));</span><br><span class="line"></span><br><span class="line"><span class="comment">//ProxyClassFactory是Proxy的静态内部类，实现了BiFunction接口</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyClassFactory</span></span></span><br><span class="line">        implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class="line">        ```</span><br><span class="line">        <span class="comment">//生成代理类的字节码</span></span><br><span class="line">        <span class="keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class="line">    proxyName, interfaces, accessFlags);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//根据二进制字节码返回Class实例</span></span><br><span class="line">            <span class="keyword">return</span> defineClass0(loader, proxyName,</span><br><span class="line">                                proxyClassFile, <span class="number">0</span>, proxyClassFile.length);</span><br><span class="line">        &#125; <span class="keyword">catch</span>```</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CGLIB"><a href="#CGLIB" class="headerlink" title="CGLIB"></a>CGLIB</h3><p>肯定不可能所有的类都实现了接口，所以动态代理并不适用所有类</p><p>这时候就需要CGLIB登场，原理是在通过ASM指令动态生成被代理类的子类，并重写所有的非private、非final的方法。</p><p>写一个国际通用入门类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello world"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写CGLIB代理类，代理类需要实现<code>MethodInterceptor</code>接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CGLibTest</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"><span class="comment">//固定写法 直接写就完事了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getInstance</span><span class="params">(Class&lt;?&gt; target)</span></span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(target);</span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开始"</span>);</span><br><span class="line">        Object invoke = methodProxy.invokeSuper(o, objects);</span><br><span class="line">        System.out.println(<span class="string">"结束"</span>);</span><br><span class="line">        <span class="keyword">return</span> invoke;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       HelloWorld helloWorld= (HelloWorld) <span class="keyword">new</span> CGLibTest().getInstance(HelloWorld<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">       helloWorld.hello();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><img src="//zheyday.github.io/2019/09/24/Spring-IoC/image-20200326181101794.png" alt="image-20200326181101794"></p><p>注意事项：</p><ul><li>委托类不能是final</li><li>方法如果是final/static，不会被拦截</li></ul><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>底层原理是动态代理，使用了两种：</p><ul><li>JDK动态代理，默认，实现接口的类，创建速度快</li><li>CGLib动态代理，适用没有实现接口的类，运行速度快</li></ul><p>如果是单例，最好使用CGLib代理</p><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="Join-point（连接点）"><a href="#Join-point（连接点）" class="headerlink" title="Join point（连接点）"></a>Join point（连接点）</h3><p>能够被拦截的地方，每个成员方法都可以是连接点</p><h3 id="Pointcut（切点）"><a href="#Pointcut（切点）" class="headerlink" title="Pointcut（切点）"></a>Pointcut（切点）</h3><p>具体定位的连接点(方法)就是切点</p><h3 id="Advice（通知-增强）"><a href="#Advice（通知-增强）" class="headerlink" title="Advice（通知/增强）"></a>Advice（通知/增强）</h3><p>表示在切点上具体需要执行的操作 ，提供了前置、后置、环绕、异常、返回这5种操作</p><h3 id="Aspect（切面）"><a href="#Aspect（切面）" class="headerlink" title="Aspect（切面）"></a>Aspect（切面）</h3><p>类似Java中的类声明，由切点和相应的<code>Advice</code>结合而成</p><h3 id="Weaving（织入）"><a href="#Weaving（织入）" class="headerlink" title="Weaving（织入）"></a>Weaving（织入）</h3><p>把Advice应用到目标对象来创建新的代理对象的过程</p><h2 id="Spring对AOP的支持"><a href="#Spring对AOP的支持" class="headerlink" title="Spring对AOP的支持"></a>Spring对AOP的支持</h2><ul><li>基于代理：现在基本不使用<br>首先看一下增强接口的继承关系图<br><img src="//zheyday.github.io/2019/09/24/Spring-IoC/image-20200327100340454.png" alt="image-20200327100340454"></li></ul><p>  分为5类：</p><p>  <img src="//zheyday.github.io/2019/09/24/Spring-IoC/image-20200327100413081.png" alt="image-20200327100413081"></p><ul><li><p>xml配置</p></li><li><p>注解</p></li></ul><h2 id="tiny-spring分析-1"><a href="#tiny-spring分析-1" class="headerlink" title="tiny-spring分析"></a>tiny-spring分析</h2><p>继续之前的代码分析</p><h3 id="step7-使用JDK动态代理实现AOP织入"><a href="#step7-使用JDK动态代理实现AOP织入" class="headerlink" title="step7-使用JDK动态代理实现AOP织入"></a>step7-使用JDK动态代理实现AOP织入</h3><p>我们知道，想要成功代理的话需要委托实例和委托实例的接口</p><p>这是一个完整的动态代理结构图，我们一点一点分析</p><p><img src="//zheyday.github.io/2019/09/24/Spring-IoC/image-20200327115224334.png" alt="image-20200327115224334"></p><p>我们把实例和Class(其实是Interface)封装进TargetSource，把TargetSource和MethodInterceptor封装进AdvisedSupport，那么MethodInterceptor是个什么东西呢？</p><p>AOP中有两个重要的角色：MethodInterceptor和MethodInvocation，它们分别对应上文提到的Advice和Join Point两个概念，我们知道AOP的作用就是在哪干，干什么，Join Point表示在哪个方法上执行，而Advice就是要干什么</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对应advice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodInterceptor</span> <span class="keyword">extends</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="function">Object <span class="title">invoke</span><span class="params">(MethodInvocation var1)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对应joined point</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodInvocation</span> <span class="keyword">extends</span> <span class="title">Invocation</span> </span>&#123;</span><br><span class="line">    <span class="function">Method <span class="title">getMethod</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以我们需要做的事情都要写在MethodInterceptor中，而且在上一部分中我们了解到它代表环绕增强，表示在目标方法前后实施增强</p><p>让我们来写一个小代码练练手，还是用之前的HelloWorldService接口</p><p>1、先写一个MethodInterceptor实现类，表示我们需要做什么<br>这个接口只有一个方法，重写即可，invocation.proceed()代表执行原方法，前后的代码是我们新增的非业务逻辑代码，这样就写好了要做什么</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimerInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">      <span class="keyword">long</span> time = System.nanoTime();</span><br><span class="line">      System.out.println(<span class="string">"Invocation of Method "</span> + invocation.getMethod().getName() + <span class="string">" start!"</span>);</span><br><span class="line">      Object proceed = invocation.proceed();</span><br><span class="line">      System.out.println(<span class="string">"Invocation of Method "</span> + invocation.getMethod().getName() + <span class="string">" end! takes "</span> + (System.nanoTime() - time)</span><br><span class="line">            + <span class="string">" nanoseconds."</span>);</span><br><span class="line">      <span class="keyword">return</span> proceed;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、接下来写要在哪做，通过前面的分析我们知道，需要实现MethodInvocation接口<br>这是MethodInvocation的继承关系图，可以看到，顶层接口是Joinpoint，也就是连接点</p><p><img src="//zheyday.github.io/2019/09/24/Spring-IoC/image-20200327115709633.png" alt="image-20200327115709633"></p><p>新建一个实现类，需要重写上述接口的所有方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectiveMethodInvocation</span> <span class="keyword">implements</span> <span class="title">MethodInvocation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Method method;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object[] args;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReflectiveMethodInvocation</span><span class="params">(Object target, Method method, Object[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        <span class="keyword">this</span>.method = method;</span><br><span class="line">        <span class="keyword">this</span>.args = args;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Method <span class="title">getMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> method;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object[] getArguments() &#123;</span><br><span class="line">        <span class="keyword">return</span> args;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getThis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AccessibleObject <span class="title">getStaticPart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> method;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、新建一个动态代理类，通过getProxy反射获取一个实例对象，然后调用invoke方法实现动态代理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkDynamicAopProxy</span> <span class="keyword">implements</span> <span class="title">AopProxy</span>, <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> AdvisedSupport advised;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">JdkDynamicAopProxy</span><span class="params">(AdvisedSupport advised)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.advised = advised;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> Proxy.newProxyInstance(getClass().getClassLoader(), <span class="keyword">new</span> Class[] &#123; advised.getTargetSource().getTargetClass() &#125;, <span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(<span class="keyword">final</span> Object proxy, <span class="keyword">final</span> Method method, <span class="keyword">final</span> Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">      MethodInterceptor methodInterceptor = advised.getMethodInterceptor();</span><br><span class="line">      <span class="keyword">return</span> methodInterceptor.invoke(<span class="keyword">new</span> ReflectiveMethodInvocation(advised.getTargetSource().getTarget(), method,</span><br><span class="line">            args));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --------- helloWorldService without AOP</span></span><br><span class="line">ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"tinyioc.xml"</span>);</span><br><span class="line">HelloWorldService helloWorldService = (HelloWorldService) applicationContext.getBean(<span class="string">"helloWorldService"</span>);</span><br><span class="line">helloWorldService.helloWorld();</span><br><span class="line"></span><br><span class="line"><span class="comment">// --------- helloWorldService with AOP</span></span><br><span class="line"><span class="comment">// 1. 设置被代理对象(Joinpoint)</span></span><br><span class="line">AdvisedSupport advisedSupport = <span class="keyword">new</span> AdvisedSupport();</span><br><span class="line">TargetSource targetSource = <span class="keyword">new</span> TargetSource(helloWorldService, HelloWorldService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">advisedSupport.setTargetSource(targetSource);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 设置拦截器(Advice)</span></span><br><span class="line">TimerInterceptor timerInterceptor = <span class="keyword">new</span> TimerInterceptor();</span><br><span class="line">advisedSupport.setMethodInterceptor(timerInterceptor);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 创建代理(Proxy)</span></span><br><span class="line">JdkDynamicAopProxy jdkDynamicAopProxy = <span class="keyword">new</span> JdkDynamicAopProxy(advisedSupport);</span><br><span class="line">HelloWorldService helloWorldServiceProxy = (HelloWorldService) jdkDynamicAopProxy.getProxy();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 4. 基于AOP的调用</span></span><br><span class="line">      helloWorldServiceProxy.helloWorld();</span><br></pre></td></tr></table></figure><h3 id="step8-使用AspectJ管理切面"><a href="#step8-使用AspectJ管理切面" class="headerlink" title="step8-使用AspectJ管理切面"></a>step8-使用AspectJ管理切面</h3><p>在完成了织入之后，需要考虑的问题就是对什么类以及什么方法进行织入，也就是切点。Spring中<code>ClassFilter</code>和<code>MethodMatcher</code>分别表示类和方法做匹配，怎么匹配呢？</p><p>AspectJ是对java的aop增强的一门语言，有单独的编译器，Spring借鉴了AspectJ风格的切点表达式，新建AspectJExpressionPointcut实现上述两个接口，通过切点解析器将AspectJ风格的表达式解析成切点表达式</p><p>pointcutParser就是切点解析器，supportedPrimitives是一个set集合，表示AspectJ语言的关键字</p><p>pointcutParser将String类型的expression解析包装成PointcutExpression，然后可以就可以匹配类和方法了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AspectJExpressionPointcut</span><span class="params">(Set&lt;PointcutPrimitive&gt; supportedPrimitives)</span> </span>&#123;</span><br><span class="line">        pointcutParser = PointcutParser</span><br><span class="line">.getPointcutParserSupportingSpecifiedPrimitivesAndUsingContextClassloaderForResolution(supportedPrimitives);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">checkReadyToMatch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pointcutExpression == <span class="keyword">null</span>) &#123;</span><br><span class="line">            pointcutExpression = buildPointcutExpression();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    字符串转切点表达式</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> PointcutExpression <span class="title">buildPointcutExpression</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pointcutParser.parsePointcutExpression(expression);</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">// 将表达式和类做匹配，返回匹配结果</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">        checkReadyToMatch();</span><br><span class="line">        <span class="keyword">return</span> pointcutExpression.couldMatchJoinPointsInType(targetClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将表达式和方法做匹配，返回匹配结果</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">        checkReadyToMatch();</span><br><span class="line">        ShadowMatch shadowMatch = pointcutExpression.matchesMethodExecution(method);</span><br><span class="line">        <span class="keyword">if</span> (shadowMatch.alwaysMatches()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shadowMatch.neverMatches()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span>其他情况不判断了！见org.springframework.aop.aspectj.RuntimeTestWalker</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>AspectJ包帮我们做好了匹配的事情，只不过我们使用动态代理而不是它的编译器实现了织入</p><h3 id="step9-将AOP融入Bean的创建过程中"><a href="#step9-将AOP融入Bean的创建过程中" class="headerlink" title="step9-将AOP融入Bean的创建过程中"></a>step9-将AOP融入Bean的创建过程中</h3><p>现在我们已经解决了在哪做，做什么的问题，接下来就要把AOP融入IOC容器的Bean中，我们首先要解决在IOC容器的哪里织入AOP，然后是要为哪些对象织入</p><p>Spring提供了BeanPostProcessor，只要Bean实现了这个接口，那么在初始化的时候会优先找到它们，并且在初始化的过程中调用这个接口，从而实现对BeanFactory无侵入的扩展</p><p>在 <code>postProcessorAfterInitialization</code> 方法中，使用动态代理的方式，返回一个对象的代理对象。解决了 <strong>在 IOC 容器的何处植入 AOP</strong> 的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"><span class="comment">//初始化方法之前调用</span></span><br><span class="line">    <span class="function">Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"><span class="comment">//初始化方法之后调用</span></span><br><span class="line">    <span class="function">Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AspectJAwareAdvisorAutoProxyCreator是实现AOP织入的关键类，它实现了BeanPostProcessor接口，它会扫描所有的切点（AspectJExpressionPointcutAdvisor包装了Pointcut和AspectJExpressionPointcut），并对bean做织入</p><p><img src="//zheyday.github.io/2019/09/24/Spring-IoC/image-20200410161806277.png" alt="image-20200410161806277"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//提供代理pointcut与advice的AspectJExpressionPointcutAdvisor不需要处理</span></span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> AspectJExpressionPointcutAdvisor)</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> MethodInterceptor)</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line"></span><br><span class="line">    List&lt;AspectJExpressionPointcutAdvisor&gt; advisors = beanFactory</span><br><span class="line">            .getBeansForType(AspectJExpressionPointcutAdvisor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">for</span> (AspectJExpressionPointcutAdvisor advisor : advisors) &#123;</span><br><span class="line">        <span class="keyword">if</span> (advisor.getPointcut().getClassFilter().matches(bean.getClass())) &#123;</span><br><span class="line">            AdvisedSupport advisedSupport = <span class="keyword">new</span> AdvisedSupport();</span><br><span class="line">            advisedSupport.setMethodInterceptor((MethodInterceptor) advisor.getAdvice());</span><br><span class="line">            advisedSupport.setMethodMatcher(advisor.getPointcut().getMethodMatcher());</span><br><span class="line"></span><br><span class="line">            TargetSource targetSource = <span class="keyword">new</span> TargetSource(bean, bean.getClass().getInterfaces());</span><br><span class="line">            advisedSupport.setTargetSource(targetSource);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(advisedSupport).getProxy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态代理类的invoke</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(<span class="keyword">final</span> Object proxy, <span class="keyword">final</span> Method method, <span class="keyword">final</span> Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">      MethodInterceptor methodInterceptor = advised.getMethodInterceptor();</span><br><span class="line">      <span class="comment">// 判断是否为要拦截的方法，是则执行 Advice 逻辑 否则正常执行</span></span><br><span class="line"><span class="keyword">if</span> (advised.getMethodMatcher() != <span class="keyword">null</span></span><br><span class="line">      &amp;&amp; advised.getMethodMatcher().matches(method, advised.getTargetSource().getTarget().getClass())) &#123;</span><br><span class="line">   <span class="keyword">return</span> methodInterceptor.invoke(<span class="keyword">new</span> ReflectiveMethodInvocation(advised.getTargetSource().getTarget(),</span><br><span class="line">         method, args));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> method.invoke(advised.getTargetSource().getTarget(), args);</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"autoProxyCreator"</span> <span class="attr">class</span>=<span class="string">"zcs.aop.AspectJAwareAdvisorAutoProxyCreator"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"timeInterceptor"</span> <span class="attr">class</span>=<span class="string">"zcs.aop.TimerInterceptor"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Creator 将对 Advisor 类型的 bean 进行扫描和处理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"aspectjAspect"</span> <span class="attr">class</span>=<span class="string">"zcs.aop.AspectJExpressionPointcutAdvisor"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 调用对应的 setter 方法进行 Property 的注入 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"advice"</span> <span class="attr">ref</span>=<span class="string">"timeInterceptor"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"expression"</span> <span class="attr">value</span>=<span class="string">"execution(* zcs.*.*(..))"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>整个流程如下</strong></p><ol><li><code>AutoProxyCreator</code>（实现了BeanPostProcessor接口）最先被实例化</li><li>其他Bean开始实例化，<code>AutoProxyCreator</code>加载BeanFactory中所有的<code>PointcutAdvisor</code>（这保证了PointcutAdvisor优先于普通Bean），然后依次使用<code>PointcutAdvisor</code>内置的ClassFilter判断当前对象需不需要拦截</li><li>如果是，生成<code>AdvisedSupport</code>交给AopProxy生成代理对象</li><li><code>AopProxy</code>实现了<code>InvocationHandler</code>接口，在invoke函数中，首先使用advised.getMethodMatcher()判断是不是要拦截的方法，如果是则交给Advice（自定义的<code>MethodInterceptor</code>）执行，如果不是，则直接执行。</li></ol><h3 id="step10-使用CGLib进行类的织入"><a href="#step10-使用CGLib进行类的织入" class="headerlink" title="step10-使用CGLib进行类的织入"></a>step10-使用CGLib进行类的织入</h3><p>前面说到，JDK动态代理只能对接口实现代理，如果类没有实现接口，那么必须要用CGLib来实现。</p><p>我们需要新建一个ProxyFactory根据TargetSource类型来自动创建代理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> <span class="keyword">extends</span> <span class="title">AdvisedSupport</span> <span class="keyword">implements</span> <span class="title">AopProxy</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在 creator 中，生成相应的动态代理的时候就可以使用工厂类的 getProxy()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> createAopProxy().getProxy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> AopProxy <span class="title">createAopProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Cglib2AopProxy(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...可以根据 TargetSource 决定使用不同的动态代理</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> AopProxy <span class="title">createAopProxy</span><span class="params">(TargetSource targetSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TargetSource修改变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TargetSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> Class&lt;?&gt; targetClass;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> Class&lt;?&gt;[] interfaces;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> Object target;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>整体流程：</p><p><img src="//zheyday.github.io/2019/09/24/Spring-IoC/image-20200621205456418.png" alt="image-20200621205456418"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;对tiny-spring项目的学习，转载自黄亿华大佬的&amp;lt;&amp;lt;1000行代码读懂Spring（一）- 实现一个基本的IoC容器&amp;gt;&amp;gt;。&lt;/p&gt;
&lt;p&gt;原网址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://my.oschina.net/flashsword</summary>
      
    
    
    
    
    <category term="Spring框架" scheme="https://zheyday.github.io/tags/Spring框架/"/>
    
  </entry>
  
</feed>
